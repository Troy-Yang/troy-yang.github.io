[{"title":"Indie hacker 新感","url":"/2024/01/27/indie-hacker-wordpress/","content":"***\n\n## Indie hacker\n如果经常逛推特的话，可能常常听到Indie Hacker 这个词，可别认为是什么印度黑客呢，原意是指独立开发者，指一个人或者两三个人的小团队包干全部的开发及运营软件产品。\n\n@tibo_maker (有点传奇，一个产品以一年一千万美金卖给了他高中同学，并且曾经四个月ship 了11 个产品)\n@marc_louvion（四五个产品，能做到 50K+ 的MRR，重点推荐）\n@levelsio （高产）\n@luosays （国产出海，有些意见挺中肯）\n\n![image](https://images.troyyang.com/2024-01-27-indie-hacker.png)\n\n我个人应该也算Indie Hacker吧，虽然是兼职的，但也算是从产品构思，UX 设计，开发，到运营一条线走通，算一算现在手上发布了两个插件，并且都还有付费用户（一个$60 的MRR，另一个$20MRR ）。虽说不能给自己带来多大的收入，但能把自己想法变现的同时，能体验不同的角色，并偶尔收到睡后收入的邮件，还是一件很美妙的事情。\n\n## Stripe Elementor\n去年年中的时候发布了第二款 wordpress插件，算到现在，半年时间，收获到了7个付费用户和 50+ 到用户安装。相对于第一款插件，这一款我个人觉得更贴近用户，并且实用效果更明显，竞争力更强，开发和构思时间也更快捷的就完成了，这就是很大的进步，因为第一个插件实在投入了太多，坑也踩了太多。\n\n举一些例子：1. 学习成本），因为是第一个软件，从着手准备到最后第一个版本，花了半年时间，学习了很多wordpress知识，license 平台管理，客户管理，ui设计等等等等，2. 技术选型），选择的是Reactjs 和 git submodules 来构建项目，原本的初心是充分利用react开发前端的灵活性，可事实证明我根本不需要如此灵活，也不需要考虑今后其他项目对这里的复用性，反而是丢失了wordpress 本身平台开发的便捷性。所以第二个插件，我果断选择了用jquery + tailwindcss 3. 产品构思），第一个插件的核心想法是提供各种支付的独立 UI组件，可事实证明，wordpress 绝大多数用户根本不需要这种支付组件，他需要的是比如woocommerce checkout 页面的stripe 集成，又或者是contact form 7 的stripe支付支持，这些才是用户支付的大部分story，正是基于这样，第二款插件就只是做了基于elementor form 的支付集成。事实证明，这一次播出去的种子，发芽成长的速度至少比第一款快了两倍！\n\n## 前五个用户是你的产品经理\n这句话在第二款插件里深深体会到了，还记得发布了两个月后，迎来了第一个付费用户，也是第一个挑战： 收到付费通知后开心不过一个小时，就又收到了退费通知，原因是安装pro 版本后，导致系统崩溃。即便很快修复了这个环境导致的问题，但早已无法挽回客户。对于退费，我并没有太过沮丧，因为前一个产品的退费请求也有好几次，但这次是记住了别被发布前的兴奋冲昏头脑，务必保证足够测试。\n\n沉寂了一个月后，迎来了真正的来自法国的付费用户，客户是一个开发公司的总监，在使用插件过程中，出现了几处异常以及一个需求缺失，所以发邮件过来请求帮助。来回十几次邮件往复，和国庆加班，终于彻底解决了他的问题，但给我最大的体会是：用户的需求实在太切实际了，比如表单里到底是one-time支付还是subscription 应该由他们的客户选择，而非一开始设计form 的时候就定好，再比如提出了也提出了支持限定次数月份或者年的订阅，最后得以让我重新设计了一个更加合理清晰的配置选项，最有价值的恐怕还是提交流程的改变，这不仅需要我深入的看了Elementor的源码弄清楚内部流程，更基于这个改进了整个设计，我相信这是其他竞品很难做到的。\n\n再往后几个月，又有几个付费用户相继提出了一些改进意见，都是非常中肯的，当然也有对插件的肯定\n\n> I can't thank you enough for your infinite patience and help. The plugin is great, super smooth and just what I need to integrate into our forms. \n\n偶然一次看推文，有人说到“前五个用户一定是你的产品经理”， 突然觉得太有道理了！一旦过了这个阶段，你应该足够对你的产品更有信心。\n\n## Indie Hacker\n最后，真心喜欢这么一个角色，让我在工作之余再也不会无所事事。","tags":["wordpress"],"categories":["wordpress"]},{"title":"wordpress 插件一年半赚$1500，还要坚持下去吗?","url":"/2022/11/27/stripe-express-summary/","content":"***\n\n今天统计了一下一年多前做的一个小插件，一共赚了$1500，二十个订阅用户，两百多有效免费用户。回顾之前的付出和现在时不时的维护，不禁在问自己，还要坚持做下去吗？\n\n![image](https://images.troyyang.com/2022-11-27-plugin-overview.png)\n\n### 插件历程\n\n要说花费的时间，零零散散加起来还是挺多的，所有东西都是现学，从wordpess 是什么，wordpress 插件是什么，php 又是从零开始，再到如何管理插件，商业思维，UI设计，程序开发，客户沟通，官网设计，文档维护。。。实在花了不少心思，好在开出的花总会结果：\n\n![image](https://images.troyyang.com/2022-11-27-plugin-timeline.png)\n\n### 后期维护\n\n除了第一版后的两三个月专心投入新功能开发后，接近有一年已经处于小功能开发和日常维护阶段，每周也花不了一两个小时在上面。如此下来，其实也能预见到插件的未来，已经达到了一个稳定甚至下降期。\n\n但是事实证明，用户的增长真的和你的投入成正比，前段时间把一些很早就想加的功能加上，并且频繁发布版本后，直接改变了下降的颓势，所以相信你的付出，用户真的能看得到。\n\n### 我的客户\n\n* 还记得第一个来自德国的神秘客户，是一个足球俱乐部，从没发邮件给我，直接购买，实在太惊讶无比，要知道当时wordpress.org公开的激活量是小于10的，而且初版程序不稳定，界面也丑陋\n* 还有一位懂技术的客户，通过不停的邮件交流，帮我留下了难得的五星好评\n* 无论免费还是付费，几乎都来自全球各地，有中途退款，取消订阅，也有特意给的NGO免费折扣，最重要的还是对客户忠诚\n\n### 成本\n\n做产品一定要说成本： 最大的成本就是我的业余时间，其次才是每年三四十美元的服务器和域名费用。 如果要说回报的话，一两千美元的直接回报真的很少，但是我却能收获到的时候经验和教训，以及客户认可的喜悦。也许等到做下一个更大产品的时候，我能更少走弯路。\n\n### 未来\n\n只是最近继续开发维护的动力越来越小，一是连续好几个月没有新付费用户，二是竞争对手的降价策略或者新功能不停推陈出新，靠原有功能实在无法吸引用户，三是看着一堆的TODO list，以及发现前期的技术选型缺陷越来越大，很难做出大的改变。。。所以就此放弃了吗？对于我这种好强的人，肯定不会放弃的，那怕还有一个付费用户在续费，也不可能放弃辛苦建立的Brand，也许新开一个插件重新整理需求也是可以的。","tags":["wordpress"],"categories":["web"]},{"title":"如何通过 AWS certified solution architect associate (SAA)","url":"/2022/07/31/how-to-get-aws-certified-solutions-architect-associate/","content":"***\n\n每天一两个小时的学习，前前后后三四个月，除了高考，也就这次考试的重视程度最高，最紧张了。回过头，看着网上评论有说小白一个月通过，我不太相信，即便对于我有一点AWS 基础的，考的过程还是很有压力。所以如果你也是准备在考的，请一定一定别低估考试的难度，务必准备足够充分。\n\n### 考证缘由\n\n说起为何想着考这个证，主要有几个原因：1. AWS的情怀，在前面的三四年里，在一些个人项目里或多或少的用过一些AWS 服务，像EC2, Lamda, DynamoDB, Route53 等，也分享过一些AWS的文章[aws_structure_series](https://troyyang.com/2018/05/12/aws_structure_series/)，所以想要继续提升aws的技能 2. 私下在和一位朋友的合作的过程中，发现国外的项目对AWS需求很大，如果能有个证，在项目上会有一定优势. 3. 个人的转型尝试 (也算是backup 吧)\n\n### 考试须知\n\n* 报名费：$150，考试失败，需重新缴费补考\n* 考试时间为 130 分钟 （划重点，对于咱们中国考生，可申请考试通融额外获取30分钟）\n* 65 道，单选题或多选题 (15道不计分，多选题题目数不定)\n* Pearson VUE 和 PSI；考试中心或在线监考考试 （我是线上考的，但硬件和网络要求需考虑）\n* 考试语言可选中英文，推荐选择中文，可在考试中来回切换中英文\n* SAA-C02试题会在8月29, 2022 过期，之后会采用C03 (所以我是看这个deadline 来安排我的考试)\n\n### 备考历程\n\n从三四月决定考试开始，一开始便不知所措，除了官网的考试大纲和样本试题，国内的考试指南文章都实在帮助很小，大部分最后还是落在各种service 范围上，想要找到一个系统性的中文学习视频或文档实在很难，所以之后的所有重心都放在了国外的资源上，下面是我自个按照学习的时间线列出的资源：\n\n* 下载考试大纲和样本试题pdf https://aws.amazon.com/cn/certification/certified-solutions-architect-associate/?c=sec&sec=resources\n* [Youtube 小哥如何通过考试](https://www.youtube.com/watch?v=jypuayQpvao) 十几分钟，但非常励志，由其是SET A DEADLINE WITH A CONSEQUENCE \n* AWS 官方学习课程 [AWS Technical Essentials](https://explore.skillbuilder.aws/learn/course/external/view/elearning/1851/aws-technical-essentials?saa=sec&sec=prep)(5小时) 非常棒的介绍和引导，免费  \n* [Youtube AWS full course by FreeCodeCamp.org](https://www.youtube.com/watch?v=Ia-UEYYR44s&t=1175s) 10小时，非常全面且免费，但缺少hands on\n* [视频教程 Stephane Maarek SAA by udemy.com](https://www.udemy.com/course/aws-certified-solutions-architect-associate-saa-c02/) ~28小时，我的学习主力，需购买大约$15，请注意这是C02，后面应该买C03了\n* [jayendrapatil.com](https://jayendrapatil.com/) 必须要提这人的博客，几乎所有备考的人都提到了他，包括了几乎所有考点，但文章真的太多，我大部分review 过，只是用来总结自己是否掌握过相关知识点，但推荐每篇都仔细看。\n* [Practice Exams](https://www.udemy.com/course/practice-exams-aws-certified-solutions-architect-associate) 需购买，大约$20，6套试题，但感觉这些难度有点高，考了四套，都才50% 到 60%，建议换其他如[whizlabs](https://www.whizlabs.com/aws-solutions-architect-associate/)\n* 官方白皮书的介绍以及FAQ\n\n最最重要的，可能就是hands on了，务必动手多练, 比如 VPC，EBS+ASG, S3 等等，一是光看大部分肯定都记不住并且连不起来，二是真的就只是为了拿证了，实在不是个合格的云架构师，一些看似很简单的设计比如两层架构，一上手才会知道自己会漏多少。\n\n### 报考流程\n登录 https://www.aws.training/ 后，最后被导航至 https://www.certmetrics.com/ ，填写好个人信息后（姓名务必使用拼音），就可以选择注册参考考试。（后期的成绩查询，证书下载都是在这个网站，PS：2021年11月后，证书已经更新，已经完全和网上看到的不一样了，黑底白字带验证码，实在不好看）\n> 可以申请考试通融延迟30分钟考试时间，如果选的是PSI， 可直接点击申请，基本申请就显示成功，之后的考试时间就会是160分钟\n\n### 考试过程\n\n#### 考前准备\n\n* 准备**护照**在手，（身份证不行，没有拼音和签名）\n* 在线考试对自己的考场要求很严，需腾空考试房间，确保房间安静，房门关闭，中途不得上厕所，一旦有人或杂音，考官会终止考试\n\n> 使用的PSI在线考试， 一直犹豫要不要选择Pearson VUE 考试中心现场考，但最终还是选择家里考，主要是因为当时PSI 有个考试优惠，以及疫情影响。如果家里网络稳定，以及对电脑有信心，最好是MAC，可以尝试在线考试。PSI 会在考试期间使用自家的浏览器，可锁定屏幕以及禁止其他软件运行，可提前下好，也可登录系统根据提示下载，下载地址在[这里](https://tca.psiexams.com/portal/testdelivery/sb_rpnow_download.jsp)\n\n#### 考试中\n选择的是9:30考，大概9点我就已经迫不及待的进入系统，按照操作，扫描护照鉴权通过后，考官会出现在对话框里，你看不见他，他能看见你，随后，他会有各种指示命令让显示各种视频角度等等检测（发现了我桌上的矿泉水都让给倒了），一切OK 会，考官会发题正式开始答题。\n\n然后就是漫长的两个小时多的答题时间。。。原本的130分钟时间倒是差不多够，但由于我申请了通融，有多余的半个小时，花了十几分钟检查标记的题目。最后实在扛不住了，点击提交，再经过焦急的几秒后，终于显示通过。。。\n\n#### 考试回顾\n\n总体感觉很多架构题还挺有难度，简单的也有，大概20，30%，比如关于DDOS, XSS防范的服务是什么， 还记得其他比如\n- Security group 相关的： web tier 和 database tier, 1433, 443\n- route53 多IP 策略（multi value）\n- VPC peering, private, public, nat\n- fraget, EKS\n- SQS, SNS\n- cloud front 的字段加密\n上面都还只是不太难的，难的都记不住了\n\n### Next\n回过头，最大的收获不是获得这个证的荣誉，而是在面临工作压力，家庭琐事等等都情况下，坚持做一件有挑战的事，并做成后的成就感。其次，就是那个小哥说的SET A DEADLINE WITH A CONSEQUENCE, 为目标设置截止日，这个深有体会，之前曾设定6.1 日考试，可因为各种各样的原因一推再推，最后7月底才完成，所以没有破釜沉舟的决心是很容易懒惰下去并背离自己的预设目标。\n\n证书有效期只有三年，所以这仅仅是一个开始，希望自己继续在云架构这条路上继续深造！\n\n最后附一张常见VPC架构图收尾，你是否都知道？\n![](https://images.troyyang.com/2022-07-31-aws-vpc-architect.png) \n\n\n","tags":["certification"],"categories":["aws"]},{"title":"一个人如何开发产品","url":"/2022/01/21/how-to-create-your-own-product-with-one-person/","content":"***\n\n经过一年的打磨，现在产品的状态应该处于稳定上升期，收获100+来自全球各地的稳定用户，包括10+的付费用户，不算大的成功，但也能激励我继续投入, 相关的输出部分提现在下面的link 中：\n* [https://itstripe.com/](https://itstripe.com/)\n* [https://docs.itstripe.com/](https://docs.itstripe.com/)\n* [https://wordpress.org/plugins/wp-stripe-express/](https://wordpress.org/plugins/wp-stripe-express/)\n\n### Idea \n\n是什么促使你有做这个产品的想法，一定是某个痛点被暴露，无论是你自己遇到或者朋友，客户遇到，做这个有前途吗？收益值得做吗？这些应该是最初的那个想法应该带给你的第一个问题。以我做的这个为例，因为之前写的一篇关于stripe在中国的微信和支付宝支付的文章，被很多读者关注，也收到很多询问问题的邮件，本着能帮就帮的原则，绝大多数邮件也都仔细回复，甚至有些还被添加了微信，在和好多用户的沟通中，发现好些都是期望用到wordpress 中去，于是开始了对WP 的了解，之前懂一点WP，知道很多人在用，可没想到居然多年过去，还是这么火爆，维基百科显示超过全球40%的网站都是由它搭建，并且还有上涨的趋势(大火的 wix 也只能占零头不到)，实在惊呆，其中不乏很多厂商依靠他来售卖插件和主题，市场还是足够大。为何我不能做一款基于WP的免费+付费插件，定位于前期面向中国，后期更多海外国家支付，再想大一点，专做Stripe 集成服务，毕竟这几年对stripe的开发还是很熟悉，而国内对这部分的了解还是很少？\n\n### 前期调研\n\n找出竞争者，看下当下的市场情况，能做到多大， 能比竞争者做的更好吗，甚至技术的调研。经过一段时间的调查，列出了一个100%匹配的竞争者以及几个间接竞争者。从调研的角度看，这个产品值得做，为什么，因为世面上已经有，就代表有市场，不用担心做的东西没人用，这倒是省去了一大顾虑，接下来的考虑就是如何超过他们。从产品角度而言，对于这个直接竞争者，我有90%的把握比他做的更好，既然他能买出产品，那为什么我不能？所以后面定的第一个短期目标就是超过他，后面从自己的客户信息来看，似乎也的确也做到了。但针对中国支付，这个市场的确有点小，估计一年最多几十个付费用户，所以产品也不能单一，可以扩展到海外其他国家，这些就是这几个间接竞争者，市场够大（做的最好的一年有上万个的客户），竞争也必然更加激烈，但也是迟早需要面对的。\n\n### 合伙人\n\n之所以想找合伙人，初衷是自己之前也独立做过一些好玩的东西，知道单打独斗的困难，不是因为事情繁杂，而是孤独，以及孤独带来的惰性，希望两个人的话，能相互互补，互相搀扶。后来也找到了一个在德国的好朋友，可惜没多久因为他忙于学业，最终还是落到了一个人头上，经过这短暂的合作，深深的明白这句“一个人可以让你走的更快，一个团队可以让你走的更远”。个人的建议是，如果是产品初期，并且自己属于产品控以及强势的一方，最好还是一个人做，会省掉你很多时间和精力，不用去想沟通的成本，后期如何合作运营，想法的冲突和利益的分配等等，一个人会让项目推进的更快更符合自己的初衷，当然事情会更多更杂。但是后期，等到产品雏形一出，甚至投入市场，则需要更多更专业的投入和设计，此时拿着产出去找投资或者合伙人不是更有信心吗？\n\n### 总体规划\n列了个之前做的计划图，实际的计划远不止这个图\n![](https://images.troyyang.com/2021-1-20-stripe-express-plugin-plan.png)\n\n### 产品研发\n\n想做一个专业的针对国外的软件产品，不是简单的前端加后端，再套个UI 就完事了，至少下面的项目是需要考虑的：\n\n#### 官网 (https://itstripe.com)\n\n（主域名，Logo, 企业邮箱，技术支持， 产品介绍，演示(Demo)，价格定位，各种条约：隐私，授权，退款条约等等）\n\n门面必须要有，并且一定要专业！其中，主域名一定要想好，后期所有推广，品牌都和这个息息相关，不能后面随便修改，官网的实现是基于gatsby JS，然后自己找了个好看点的主题魔改，虽然还是很丑（一位付费用户抱怨这网站看起来不专业），但还能将就用，最后托管到gitlab 的page 上，后端就一个AWS lambda 提供API 来发送contact me的邮件。\n\n企业邮箱可以使用阿里云的企业邮箱服务，5年免费，可以薅一下，有企业邮箱会让你的网站更加专业，客户会更加信任，什么sales@itstripe.com, support@itstripe.com 等等等等，虽然都是我一个人在打理，哈哈\n\n条约，一定要重视，从google analysis 上看，神奇的是，如此偏门的页面居然也有不少人会去点击，让我不得不重视其中的每一条每一款。 \n\n#### 产品帮助文档(https://docs.itstripe.com)\n\n产品当然得有帮助文档，要不然客户每次来烦你，你的邮件一定会爆的，什么quick start guide, setting, Q&A 放文档上就好了，节约你和客户的大把时间。 \n\n#### 产品 Demo (https://itstripe.com/demo, https://demo.itstripe.com)\n\n当然也少不了了，哪怕是静态的也好，这是目标客户点击率最高的地方。\n\n#### 产品研发 ([https://wordpress.org/plugins/wp-stripe-express/](https://wordpress.org/plugins/wp-stripe-express/))\n\n做的WP插件，需要考虑，如何安装，激活，如何区分付费和免费用户，如何升级付费用户，客户如何支付，如何管理License（是否过期等）\n\n自学了php，wordpress API, 外加 4 个 react repo(官网，文档，插件后端，插件前端) ，对于如何集成付费用户，又使用到了freemius 来管理代码和客户，为了产品的介绍，又摸索学习了Figma 设计图形，logo \n\n#### 运营\n\n保证优质的回复每一封客户的邮件，遵守退款条约（退了两三次，好心痛），从客户需求里或者自己挖掘新功能（千万别模仿竞争者，保持产品的独立性），保持定期产品更新，让目标客户或者现有客户知道这产品的活力，WP 上不少插件都是没人维护状态。\n\n下面是我指定的 TODO 运维图，有些是客户提的需求，一些来自自己发现需要优化的地方。\n![](https://images.troyyang.com/2021-1-20-stripe-express-plugin-todos.png)\n\n#### 客户的 feedback 是你产品最大的财富\n下面是最近来自德国一位付费用户的邮件回复，真的深深的让我体会到，你的产品远没你想的那么好，但你的付出总会得到回报：\n\n> So I’m happy about you being so responsive and willing to help, because looking at the low number of installations shown for your free version on Wordpress org, the at first not working feature for metadata, broken homepage and the failed payment and no imprint with physical company address on homepage did not make the very best impression at first. You have proved, that my first impression was not right, but I bet others that evaluate the best Stripe plugin might come to a similar conclusion. \n\n### 思考\n\n这一年以来，还是花了太多的业余时间在这上面，包括多少个周末，甚至大理游玩都在弄，到现在也只是踏出了第一步， 列表里还列了很多关于这产品的TODO LIST，包括UI 的更新，大功能新增等，希望来年能完善好。\n\n产品的故事实在太多，写着写着就停不下来，也许这就是折腾的意义，对提升个人知识的广度实在太多了","tags":["stripe"],"categories":["stripe"]},{"title":"2021年度回顾","url":"/2022/01/20/my-2021/","content":"***\n\n简单的回顾，2021，还是处于疫情阶段，经历的人和事也挺多：\n\n* 经历人生第一次公司大裁员（自己没被裁，可看着身边一半以上的人走人流，还是感慨万分，不是因为幸运，而是归属感和危机感深深刺激了自己）\n* 自己业余开发的stripe express 产品发布一年，收获100+来自全球各地的用户，包括10+的付费用户\n* 用近半年兼职为一日本朋友开发web系统，收获了除开发经理以外，产品经理和项目管理更多角色的担当\n\n### 关于裁员\n\n作为一家美企研发中心，面对美国严峻的疫情情况，公司收入锐减，不得已开启裁员模式，看着昔日熟悉的面孔，看着离开的人开开心心拿着N+2的package离开，其中还不乏拿着顶格12+2的同事，但又同时饱含泪水的拥抱离开。。。这个时候不禁在想，到底留下来的才是幸运儿还是离开的呢？？（现在看必须是离开的，因为大多数人在一年后又重新回到公司）\n\n这次裁员，最大的感受还是人不能过的太安稳，尤其在外企这种生活工作很balance的节奏，如果不规划好自己的未来，很容易温水煮青蛙。其次是安全感，安全感一定不是公司给的，即便你是处于全球500強，so what? 一定要有自己的一套技能和体系，只有这种安全感才会让你坦然面对常说的35或者40岁危机\n\n### 关于自己做产品\n\n感想太多，单独写了另一篇 [一个人如何开发个人产品](https://troyyang.com/2022/01/21/how-to-create-your-own-product-with-one-person/)\n\n### 关于兼职项目\n\n一个机缘巧合，开始为一来自日本的华人朋友开发系统，需求从原本最初计划的匹配工具发展到日本广为流行的案件人才管理系统。找了个朋友做后端，我就负责需求沟通，前端开发，测试以及Demo等，技术栈选择的是基于AWS 的 serveless 架构。所获得的不仅仅是收入上的提高，更是如何系统的从0到1，从需求到，开发、架构整个流程的系统化，由其在AWS 上的各种服务，以前如果只是小打小闹的自己使用，那么这次算是一次商业化应用的实践。\n\n### 2022 计划\n\n不想写什么读多少本书，短期目标就先拿个 AWS SAA 证书吧","tags":["misc"],"categories":["misc"]},{"title":"中国用户如何免费激活Stripe?","url":"/2021/06/02/activate-stripe-in-china-for-free/","content":"\n# 中国用户如何免费激活Stripe?\n\n本文会介绍无需开设海外银行账号或者香港账号，并免费的通过注册激活Stripe账号并提现，亲测有效！\n\n主要通过使用万里汇海外账号绑定激活，其中万里汇是蚂蚁金服旗下的产品，值得可靠。（不是给万里汇打广告哦）\n\n### 什么是Stripe\n\n想象你是一个跨境电商，想要把产品卖到全球，却面临一个问题，商品标价$100，日本客户想直接支付日元，欧洲客户想支付欧元。。。你不可能要求客户说我只支持美元，请兑换后再支付吧？\n\n所以如果你还不知道Stripe，那推荐你去了解下。作为和PayPal一样存在的支付巨头（现在市值 $950亿），在国外早已火得一塌糊涂，使用他作为支付平台的商家和网站数不甚数，消费者渗透率覆盖了全球135个国家。。。\n\n[]()\n\n### 中国商户，NO\n\n遗憾的是，如果你是身在中国，那么是不能激活Stripe 账号的（不激活只是注册账号倒是可以，但是没法收款和体现，只能测试），可以查看现在商户支持的[40多个国家/地区列表](https://stripe.com/global), 其中香港是可以的。所以你能看到，这个注册公司地址里是没办法选择中国🇨🇳的，That's the problem!\n\n![](/images/uploads/2021-06-02-stripe-reg-china-issue.png)\n\n### 如果解决？万里汇 或者 TransferWise\n\n问题的瓶颈在于stripe 激活的时候，需要提供你的商业信息以及银行信息，并且保证银行上的名字和账号里的个人姓名一致。但又由于商业信息的国家地区只有上面提到的，所以也就导致中国用户没办法激活。\n\n解决办法的思路就是，使用万里汇注册个香港账号或者其他国家的银行账号（虽说是虚拟的，但和实际没区别），然后再根据账号的信息拿去Stripe激活，看似简单，但还有很多坑需要趟，且听我慢慢道来。\n\n---\n\n### 注册万里汇\n\n点击注册地址 [https://portal.worldfirst.com.cn/register](https://portal.worldfirst.com.cn/register)， \n\n1. 然后按步骤选择支付网关, 这里可以按个人情况多选几个(最好把stripe 勾选上)，虽然我也不知道有多大影响\n\n![](/images/uploads/2021-06-02-worldfirst-reg-gateway.png)\n\n2. 选择类型，可以是个人， 也可以是公司，这里我选的个人\n\n3. 填写基本信息，按部就班的填好就行，注册就算成功\n\n### 认证账号\n\n注册好了，是非认证状态的，这时是不能创建海外账号，还需要提供相应的信息上传去验证（据说可以支付宝快捷验证，但是我没发现有，只能拍照上传）\n\n认证一般会持续一两天验证，等着收邮件就好了，如果有问题，可以联系自己的万里汇客户经理（真是一对一服务啊，这点好）\n\n![](/images/uploads/2021-06-02-wordfirst-reg-home-page.png)\n\n### 创建海外货币账户\n\n终于到了关键步骤了，这里可以创建多个账户，每个账户就像自己银行卡一样，有卡号，为了stripe 注册方便，我创建了一个香港账户和一个美国账户\n\n![](/images/uploads/2021-06-02-wordfirst-account-detail.png)\n\n到了这一步，恭喜你，你已经开通了海外账户！关键是这个银行信息对后面的Stripe激活是非常重要。\n\n---\n\n## 创建和激活 Stripe 账号\n\n首先创建Stripe 账号，[https://dashboard.stripe.com/register](https://dashboard.stripe.com/register)， 国家/地区可以选择香港，创建好之后，登录进入主页面， 这个时候如果你暂时不想激活，是完全可以的，可以切换**测试**模式进行你的支付开发测试，**测试**模式基本和**在线**模式一模一样，除了测试的支付账号是假的以外 （PS， 我就是没激活使用了一年多，纯粹作为开发使用）\n\n![](/images/uploads/2021-06-02-stripe-dashboard.png)\n\n### 激活Stripe 账户\n\n点击 **激活你的账户** ， 这里看起来有很多步骤，不用怕填错，后面都是可以跳回去改的。\n\n公司结构：\n\n![](/images/uploads/2021-06-02-stripe-activate-comany-info.png)\n\n选择香港，或者其他上面货币账号国家，地址可以填银行账号地址，类型可以选个人（如果公司的话，据说stripe 会对你账号保护性或者服务更好），点击下一步\n\n公司代表：必须是你自己在上述银行账号的姓名，否则可能会无法体现到你银行\n\n![](/stripe-activate-represent-name-info.png)\n\n地址信息可以继续用银行地址，电话号码最好是用中国的，可以选CN, 填写自己号码，因为后面可能会用来用来登录短信验证之类的，身份证ID 这个我没记错的话，是随便找的一个ID（只要位数和格式对了就行） ☹️\n\n![](/images/uploads/2021-06-02-stripe-activate-represent-info.png)\n\n银行详情：选择在万里汇创建的银行信息就行\n\n![](/images/uploads/2021-06-02-stripe-activate-bank-info.png)\n\n然后一直填下去，保存\n\n### 激活成功了吗？\n\n上述没问题的话，确实激活成功了，你也可以切换到线上模式去收款了，但是却无法提现（转账）到你银行卡里，还有两个重要的未完成步骤警告：\n\n身份信息不匹配（个人信息验证失败，当然了，ID 都是假的） 和 US Tax Form （美国税收表）\n\n![](/images/uploads/2021-06-02-stripe-activate-ux-tax-sign.png)\n\n两个问题一个一个解决：\n\n- ID 不匹配，进入提示的配置，只需要上传自己的身份证正反面就好了，一天左右就验证成功（不知道如何验证的，可能是后台人工验证，保证姓名一致就行，所以一定上传自己真实的身份证就，地址用自己中国地址）\n- W-8 form，一定要选非美国居民（勾选No），然后点击提交，会被导航至表单填写页面，基本信息stripe 已经帮你预填了，只需要签上个人姓名就好了\n\n![](/images/uploads/2021-06-02-w-8-form.png)\n\n[documents-for-identity-and-home-address-verification](https://support.stripe.com/questions/documents-for-identity-and-home-address-verification#upload)\n\n[w-8-forms-collected-by-stripe](https://support.stripe.com/questions/w-8-forms-collected-by-stripe)\n\n等着这两个错误完成后，这个账号就算真正激活完成，并可以完成提现（每天，并且非常快）。\n\n![](/images/uploads/2021-06-02-stripe-payout.png)\n\n---\n\n### 万里汇提现到人民币(成功)\n\n现在万里汇香港账号已经有收到的港币了，但如果需要的话，需要转为人民币（可转到支付宝），但根据万里汇客户经理说明，这是需要提供相应凭据，也就是stripe 或者 paypal 上的支付记录，表明来历明确。提现过一次，因为金额不大，并且提供了paypay 的收款记录，所以成功提现。\n\n特别提醒的是，这篇文章目的只是为激活stripe指南， 不为跨境转账成功负责，请酌情选择。\n\n特此声明，本文禁止转载至除 troyyang.com, [itstripe.com](http://itstripe.com) 以外的网站\n\n\n相关推荐文章：   \n[wordpress stripe插件，支持微信和支付宝](https://troyyang.com/2020/12/30/wordpress-stripe-express-released/)   \n[stripe集成 微信和支付宝](https://troyyang.com/2018/01/21/stripe_guide_alipay/)   ","tags":["stripe"],"categories":["stripe"]},{"title":"Wordpress 插件 Stripe Express 发布啦！","url":"/2020/12/30/wordpress-stripe-express-released/","content":"***\n\n## Stripe Express 是什么？\n简单来说，Stripe Express 是一款针对wordpress 平台，帮助你使用 stripe 快速，方便完成跨境支付的一款免费插件（扩展功能收费）。其中，包括多种已经创建好的支付组件，包括一次性支付(one-time)，电子钱包（支付宝，微信，Apple Pay, Google Pay，下面重点会提到微信和支付宝），表单支付等等组件，需要提及的是，上面的组件都支持常见的各种信用卡，Master card, Visa, 等等等等，以及其他国家地区的主流支付方式比如 Bancontact, FPX, EPS, SEPA, Giropay, Sofort, iDeal。\n\n所以，只有你有一个 Stripe 的账号，那么超过三十多个国家地区的客户都可以向你支付（对于微信和支付宝，你无需申请支付宝或者微信的商家账号，即可免费收款）。\n\n\n问题: 什么人更需要这个组件？   \n回答: 现阶段，因为还没集成woocommence， 所以如果你没有一个完整的电子商务网站比如使用 woocommence搭建，只是一个简单的Wordpress 网站，但是你又有自己的产品或者服务需要销售，而你只是想你用户简单的点击购买，付款。\n\n[wordpress 插件传送门](https://wordpress.org/plugins/wp-stripe-express/)\n\n![](https://images.troyyang.com/stripe-express-org-preview.png)   \n\n## itstripe.com \n\n![](https://images.troyyang.com/itstripe-preview.png)   \n\n在我们国内，大部分人肯定知道Paypal，却不知道Stripe，更别说用过，当然也和Stripe 暂不支持中国商家的原因分不开。殊不知，国外Stripe普及程度远大于我们的想象，很多网站都会加上对Stripe 的支持，因为这意味着你的网站可以面向全世界超过30个主要国家的客户收费，包括中国！所以想要做跨境支付的话，Stripe 你必须要熟悉！   \n\n众所周知，Wordpress全世界超过40%的网站都是他创建的，而且现在也依旧火爆。再加上之前很多朋友都在咨询我关于 stripe 在wordpress上的问题，所以主要侧重点会是在 stripe express 这款插件上。其次，网站会包括产品介绍，以及插件的文档，还有和stripe 相关集成服务，如果你有集成这方面的需求的话，或者Web 的支付开发，可以联系我们。   \n\n## Stripe，微信 和 支付宝   \n这是一个最重要的原因之一促使我想要做这么一个东西。有这么一部分人：1. 小商家或者个人网站用户想要接入微信或者支付宝，方便国内用户收费，2. 国外的中小网站想要针对中国用户微信和支付宝收费。但是对于他们而言，由其老外，要想接入微信或者支付宝支付接口，门槛还是有点高，需要去申请商家账号\n\nstripe 却在这方面有着天然优势，由于已经和alipay 和 wechat 达成协议，Stripe 完全可以实现上面的收费，其中stripe 会收取3.4% + $0.50每笔的服务费。   \n\n之前写过一篇关于 [stripe集成 微信和支付宝](https://troyyang.com/2018/01/21/stripe_guide_alipay/)的文章，反响挺大的，看到很多评论和转载，也收到很多咨询的邮件，但是之前的那篇从技术角度其实有点老了，我会另外抽时间重新写一个更通用的集成方式（已经在这款插件中实践了）\n\n## 后续\n回想这半年多的开发时间（包括插件和官网），白天正常上班，晚上继续开发，连周末都不想出门，像打鸡血一样的完善产品，终于迎来了发布的日子。无论这款插件将来如何，安装量怎样，有过这么一段为了某个目标而全力以赴的日子也是极好的！\n\n","tags":["wordpress"],"categories":["web"]},{"title":"Mobx在项目中的实践 及 与Redux的比较","url":"/2020/12/20/mobx/","content":"\n之前在公司FEE内部做过一次技术分享，主要关于Mobx在项目中的使用一年后的体验以及和Redux 的一些比较（因为我们项目之前的状态管理选型选择的是mobx，而其他项目组的同学选择主要是Redux或者还在纠结如何选）。\n\n以下都是根据查询各种资料后的个人理解概览\n\n## Mobx Overview\n> Mobx looks like a properties tracking and reaction lib.   \n> 基础部分就省了，只说结论：Mobx 看起来是属性追踪及作出相应反应的库，和Redux 不一样的是，他的状态是mutable的。\n### Mobx 4 & 5\n* Mobx 4 Limitations (Observable)\n* Mobx 5 Proxy based (Only ES 6 Browser, no polyfill)\n\n## Mobx & Third-Party view lib\n* mobx & mobx-react\n* redux & react-redux\n* mobx & mobx-arch & mobx-backbone 有吗???\n\nMobx 是可以单独使用的，这点和Redux一样，可以不需要依赖于任何UI 库像，React, Vue，当然如果把他们结合到一起，那才能发挥出最大的作用，所以就理所应当的有mobx-react。\n\n我们公司内部有个UI 库叫arch，很老的了，requirejs时代的，比react, vue, angular还早，没有响应式的更新，核心只有一个render 方法，所以其实可以通过Mobx 简单改造为响应式的，一旦外部属性发生变化，就会触发重新渲染，至于内部状态嘛，呵呵，不考虑了，反正这只是个例子。\n```\nvar { observable, autorun } = require(\"mobx\");\nvar Entity = require('xx/xxxx/entity');\n\nvar todoStore = observable({\n  todos: [],\n  get completedCount() {\n    return this.todos.filter(todo => todo.completed).length\n  }\n})\n\nautorun(function () {\n  // For Backbone\n  this.xxxBackBoneComponent = new Entity({\n    model: todoStore.todos,\n    editable: true\n  });\n\n  // For Arch\n  active.render($html, () => {\n    this.xxArchComponent = arch.getComponent(xxx);\n  });\n})\n\ntodoStore.todos[0] = {\n  title: \"Take a walk\",\n  completed: false\n}\n```\n\n## Mobx Store Design\n* [Offical guide on Store design](https://mobx.js.org/defining-data-stores.html)\n* [Best Practice](https://medium.com/dailyjs/mobx-react-best-practices-17e01cec4140)\n* UI State & Domain State\n\n这是我觉得最难的部分，如何设计好Mobx的Store？官方给出的一个[guide](https://mobx.js.org/defining-data-stores.html) 是划分为Domain store 和 UI store。Domain store和Redux的one-single store 可不一样，这里是可以有多个的，像users, books, movies, orders 都可以是一个Domain Store， 至于UI store，暂时我们只是存储一些全局的属性。所以，我们的项目中Store的结构大致如下:\n```\nstores\n--root.ts\n--domain\n----aaaStore.ts\n----bbbStore.ts\n--ui\n----application.ts\n```\n\nroot.ts初始化所有domain和ui store:\n```\nexport default class RootStore {\n  @observable\n  aaStore;\n\n  @observable\n  bbStore;\n\n  @observable\n  applicationUIStore;\n\n  constructor() {\n    // Domain Store Init\n    this.aaStore = new AStore(this);\n    this.bbStore = new BStore(this);\n    ...\n\n    // UI Store Init\n    this.applicationUIStore = new ApplicationUIStore(this);\n    ...\n  }\n}\n```\n\n但是在实际的问题中，我们发现大部分的状态其实都是本地UI状态，（也许有人说用setState啊，如果业务复杂，状态很多, 并且基本会依赖其他store，最好抽出来）所以，问题来了，这些ui store我们放在哪里呢？同时，我们需要把Container 组件里的状态隔离开来，为什么隔离，一是因为UT 不好写（因为有inject，所以在UT里需要写很多Provider），二是傻瓜组件更不容易出错，参考Redux的connect用法，我们得到下面的结构：\n```\nContainerAComponent\n--ContainerAComponent.tsx\n--ContainerAComponentUIStore.ts\n```\nContainerAComponentUIStore.ts\n```\nexport default class ContainerAComponentUIStore {\n  rootStore;\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n  }\n\n  @observable\n  addHoc = '';\n  \n  @action.bound\n  onAdhocChange = (addHocNewValue) => {\n    ....\n  }\n```\nContainerAComponent.tsx\n```\nexport class ContainerAComponent extends React.Component {\n  handleAdhocChange = (e) => {\n    this.props.onAdhocChange(e.target.value);\n  }\n  ...\n}\nexport default connectComponentStore(ContainerAComponent, ContainerAComponentUIStore);\n```\n这样，我们导出了两个组件，一个是ContainerAComponent，就是一个简单组件，我们可以通过传统传props的方式去测试组件核心内容，另一个是HOC组件，其实是不用测试的。\n\n而至于connectComponentStore方法，就是一个很简单的HOC\n```\nexport default (WrapperedComponent, ComponentStore) => {\n  @inject('appStore')\n  @observer\n  class Connect extends React.Component {\n    @observable componentStore;\n\n    constructor(props) {\n      super(props);\n      this.componentStore = new ComponentStore(props.appStore);\n      this.ref = createRef();\n    }\n\n    static displayName = `${WrapperedComponent.displayName || WrapperedComponent.name}-withUIStore`\n\n    componentDidMount() {\n      this.componentStore.mapState(this.props);\n    }\n\n    componentDidUpdate(preProps, preState) {\n      this.componentStore.mapState(this.props);\n    }\n\n    render() {\n      return (<WrapperedComponent ref={this.ref} {...this.componentStore.toProps} {...this.props} />);\n    }\n  }\n\n  return Connect;\n};\n```\n\n我们业务里，绝大部分都是用到的这种本地UI Store + 简单组件组合这种方式，也许就是所谓的local state component （忘了哪里听到的了）\n\n### Mobx-State-Tree（MST）\n也许MST在大型项目中使用是个很好的方式，但我们暂时还没有去尝试。\n\n### Project Structure\n下面是Mobx的一些项目组织结构参考资料：\n\nhttps://medium.com/@daniel.bischoff/how-to-structure-your-mobx-react-app-8fd6d9d821a4     \nhttps://github.com/gothinkster/react-mobx-realworld-example-app   \n\n\n## Mobx-React vs Redux-React\n个人简单的一些看法：\n* Workflow\n* Freestyle vs Strict\n* OOP styles vs FP\n* Small vs Large\n* Time-traval problem (Resolved by MST)\n* Container components (Inject vs Connect)\n* [redux-crud-example](https://github.com/sitepoint-editors/redux-crud-example/tree/master/src) & [mobx-crud-example](https://github.com/sitepoint-editors/mobx-crud-example/tree/master/src)\n\nhttps://medium.com/@cameronfletcher92/mobdux-combining-the-good-parts-of-mobx-and-redux-61bac90ee448   \nhttps://www.sitepoint.com/redux-vs-mobx-which-is-best/\n\n### Learning Redux\n在一些小项目中用过Redux, 不得不说，Redux的学习成本要比Mobx高得多，比如下面的点，\nredux, reducer, action, container component, selectors(reselect), redux-thunk, normalizing, ducks, and more waiting...\n\n## Others links\n### [Mobx-Best-Practice](https://medium.com/dailyjs/mobx-react-best-practices-17e01cec4140)\n### Decorator (ES7/TS) vs no-decorators\n\n## End\n如果你有更好Mobx使用的一些心得，欢迎交流！\n","tags":["react"],"categories":["web"]},{"title":"纯JS实现按多列排序","url":"/2020/05/03/multi-sort-implement-with-native-js/","content":"\n### 重要的事情还是要说的\n项目里没引用 **lodash** （因为和 underscore.js 冲突）\n\n### 问题\n数据结构类似这种：\n```\nconst testData = [\n  { name: '1', primary: true, startDate: '2018-01-01T08:00:00Z', endDate: '2018-05-01T08:00:00Z' },\n  { name: 'A', primary: true, startDate: '2018-02-01T08:00:00Z', endDate: '2018-06-01T08:00:00Z' },\n  { name: 'a', primary: true, startDate: '2019-02-01T08:00:00Z', endDate: '2019-05-01T08:00:00Z' },\n  { name: 'b', primary: false, startDate: '2019-02-01T08:00:00Z', endDate: '2019-02-01T08:00:00Z' },\n]\n```\n最近项目中有大量的对排序的新需求，由其是按多列来排序， 新需求大致如下：\n\n- Archived 为true的排列到最后，否则排最前面\n- 然后，按照 StartDate 时间，如果最新，则排前面\n- 然后，如果 StartDate 相同，则按照 EndDate 来排，\n- 然后，如果 EndDate 也相同，则按照 name 的字母表的顺序排\n\n\n同时呢，之前项目中也有很多类似的需求：\n\n- 先按照 ModifiedDate 排，\n- 如果相同，则按 name 字母表顺序\n\n或者\n- Primary 为true 的排前面\n- 如果Primary 相同， 按照 name 字母表排序\n\n还有更多的类似需求，我们项目里原来有个 Sort.js 的公共方法来处理这些排序，选取了其中最长的一个 (其实上面需求的每一个实现都和这个差不多)\n```\nconst sortFlattenPrograms = (flattenPrograms) =>\n    flattenPrograms.sort((a, b) => {\n      // first sort by archived: unarchived first\n      if(a.archived && !b.archived) {\n        return 1;\n      } else if(!a.archived && b.archived) {\n        return -1;\n      }\n\n      // sort by start date: latest first\n      let dateCompareResult = compareDateLatestFirst(a.startDate, b.startDate);\n      if(dateCompareResult !== 0) {\n        return dateCompareResult;\n      }\n\n      // sort by end date: latest first\n      dateCompareResult = compareDateLatestFirst(a.endDate, b.endDate);\n      if(dateCompareResult !== 0) {\n        return dateCompareResult;\n      }\n\n      // sort by program name - location name: alphabetically (ignore case)\n      const nameCompareResult = compareStringAlphabeticallyIgnoreCase(getProgramFullName(a), getProgramFullName(b));\n      if(nameCompareResult !== 0) {\n        return nameCompareResult;\n      }\n\n      return 0;\n    });\n```\n\n是不是很长，很丑，而且这只是一个排序，还有很多这种和0比较，然后再比较，所以继续加下去肯定不可取，维护是个很大的问题，UT 也很难写，要是能抽出中间部分就好了？？？\n\n### 解决办法\n先贴代码，其实核心就是抽取上面的各种comparator， 并且采用链式的方式执行，这里使用reduce方法来取了个巧，其实，查看了lodash的实现后， 他们采用的是 while 实现。\n\n注意排序的顺序，是按照从右到左，我想的是尽量和 **functional programming** 的方式来写，并且compose 方法在lodash 里也是这个顺序，如果想改为从左往右，只需要将 **reduce** 改为 **reduceRight** 即可\n```\n/**\n   * Sort by order list from right to left\n   * For example: we want to order by start date, if date equal, then order by end date, if equal, then name\n   * composeOrderBy([oderByName, orderByEndDate, orderByStartDate])\n   * @param {*} comparators\n   */\n  const composeOrderBy = (comparators) => {\n    const makeChainedComparator = (first, next) => {\n      return function (a, b) {\n        var result = first(a, b);\n        if(result !== 0) return result;\n        return next(a, b);\n      };\n    };\n    return comparators.reduce(function (chained, first) {\n      return makeChainedComparator(first, chained);\n    });\n  };\n```\n\n所以，上面的需求可以简单改为下面，其实comparators 是一个我预先定义好的各种比较方法\n```\n// 预先定义的方法\ncomparators = {\n  compareStringField: (field, ignoreCase = true)=> (a, b) => { ... },\n  compareBoolField: (field, trueFirst = true) => (a, b) => { ... },\n  compareDateLatestFirst: (field) => (a, b) => { ... },\n}\n\ndata.sort(composeOrderBy([\n        comparators.compareNameIgnoreCase(),\n        comparators.compareDateLatestFirst('endDate'),\n        comparators.compareDateLatestFirst('startDate'),\n        comparators.compareBoolField('archived', false)\n      ]));\n\ndata.sort(composeOrderBy([\n        comparators.compareNameIgnoreCase(),\n        comparators.compareDateLatestFirst('modifiedDate')\n      ]));\n```\n\n最终还是需要用到 array的sort 方法，但由于这不是纯函数，所以保险的做法就是调用sort前，先在clone一下","tags":["js"],"categories":["Web"]},{"title":"神奇的 ES6 继承执行顺序问题","url":"/2019/12/17/amazing-es6-exec-order-issue/","content":"刷推的时候无意间发现一位google 工程师发的一个感叹，感叹发现的一个神奇的JS 6继承顺序问题。。。\n\n![](/images/uploads/2019-12-17-js6-class-order-miracle-tweeter.jpeg)\n\n![](/images/uploads/2019-12-17-js6-class-order-miracle.png)\n\n\n\n仔细看了看，确实好神奇，于是好奇的看了看babel转换出的结果：\n\n```\nvar SuperClass = function SuperClass() {\n  _classCallCheck(this, SuperClass);\n\n  _defineProperty(this, \"foo\", function () {\n    return console.log('foo init in supper class');\n  }());\n\n  console.log('super construtor');\n};\n\nvar WhatEver =\n/*#__PURE__*/\nfunction (_SuperClass) {\n  _inherits(WhatEver, _SuperClass);\n\n  function WhatEver() {\n    var _this;\n\n    _classCallCheck(this, WhatEver);\n\n    console.log('before sub class constructor');\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WhatEver).call(this));\n\n    _defineProperty(_assertThisInitialized(_this), \"foo\", function () {\n      return console.log('foo init in sub class');\n    }());\n\n    console.log('after sub class constructor');\n    return _this;\n  }\n\n  return WhatEver;\n}(SuperClass);\n\nnew WhatEver();\n```\n\n就和他猜测的一样：没有supper的时候，字段的初始化是早于构造函数执行的，有supper的时候，字段初始化是在构造函数里的super后执行！\n\n个人看法是故意放super之后是为了能在字段里访问到父类的字段？\n","tags":["js"],"categories":["web"]},{"title":"使用NetlifyCMS在线编辑Github上的博客","url":"/2019/11/24/githug-netlify/","content":"### Netlify CMS 介绍\n\n使用Netlify CMS我感觉有以下优点：\n\n* 无缝支持Hexo 等十几种主流静态网站生成器 的 **文章后台管理***   \n* 可视化在线编辑、新增github 上的markdown\n* 自带图片上传功能\n* 自动部署\n\n支持列表：\nJekyll, GitBook,Hugo, Gatsby, Nuxt, Next, Gridsome, Zola,Hexo, Middleman, Jigsaw,Spike ,Wyam,Pelican,VuePress,Elmstatic,11ty,preact-cli\n\n![](/images/uploads/2019-11-24-netlifycms-list.png)\n\n### 为什么使用它\n\n对于我的情况：使用Hexo 网站生成器，托管在github上 <https://github.com/Troy-Yang/troy-yang.github.io>，其中Source branch是存放markdown等生成前分支，Master branch存放的是生成后的静态文件分支。\n对于以前，如果要写一篇文章，基本是在source 分支里，新增一个markdown文件（可github上在线添加或者本地新增然后push），然后自动触发github 上配置的travis 自动部署流程，整体感觉已经很不错了。现在配置上Netlify CMS后， 可视化的在线编辑以及图片管理更加方便，可以随时随地发文章。\n可惜, Netlify有个致命缺点：**需要翻墙访问**\n\n### HEXO  NetlifyCMS 配置\n\n只需要在hexo 的source/ 目录下添加admin 目录，新增下面两个文件：\n\n```\nconfig.yml\nindex.html\n```\n\nconfig.yml需要根据自己情况进行配置：\n\n```\nbackend:\n  name: git-gateway\n  branch: Source\n\n# This line should *not* be indented\nmedia_folder: \"source/images/uploads\" # Media files will be stored in the repo under images/uploads\npublic_folder: \"/images/uploads\" # The src attribute for uploaded media will begin with /images/uploads\n\ncollections:\n  - name: \"blog\" # Used in routes, e.g., /admin/collections/blog\n    label: \"Post\" # Used in the UI\n    folder: \"source/_posts\" # The path to the folder where the documents are stored\n    create: true # Allow users to create new documents in this collection\n    slug: \"{{slug}}\" # Filename template, e.g., YYYY-MM-DD-title.md\n    fields: # The fields for each document, usually in front matter\n      - {label: \"Layout\", name: \"layout\", widget: \"hidden\", default: \"post\"}\n      - {label: \"Title\", name: \"title\", widget: \"string\"}\n      - {label: \"Publish Date\", name: \"date\", widget: \"datetime\"}\n      - {label: \"Tags\", name: \"tags\", widget: \"list\", required: false}\n      - {label: \"Categories\", name: \"categories\", widget: \"list\", required: false}\n      - {label: \"Photos\", name: \"photos\", widget: \"list\", required: false}\n      - {label: \"Excerpt\", name: \"excerpt\", widget: \"string\", required: false}\n      - {label: \"Body\", name: \"body\", widget: \"markdown\"}\n      - {label: \"Permalink\", name: \"permalink\", widget: \"string\", required: false}\n      - {label: \"Comments\", name: \"comments\", widget: \"boolean\", default: true, required: false}\n```\n\nindex.html\n\n```\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>Content Manager</title>\n</head>\n<body>\n  <!-- Include the script that builds the page and powers Netlify CMS -->\n  <script src=\"https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js\"></script>\n  <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n</html>\n```\n\n### Netlify 端配置\n\n#### 创建 Netlify website\n\n注意：和大部分人的做法不同的是，我Deploy到的地方并不是托管在Netlify自己的平台上，而是github上，所以这里我选择部署的是Source分支，而不是Master，因为我只是想要Netlify去修改我的Source分支，然后触发Travis自动发布到Master分支。\n\n但是我依旧需要填写Netlify的部署，因为Netlify会自动帮我创建域名为troyyang.netlify.com的网站，任何我Source分支上的修改也会触发这个网站的自动部署\n\n![](/images/uploads/2019-11-24-create-netlify-website.png)\n\n#### 开启Netlify Identity 和 Git Gateway\n\n在Setting 的 Identity选项下：\n\n1. Enable Identity service\n2. External providers 新增github\n3. Enable Git Gateway\n\n### 发布测试\n打开 https://troyyang.netlify.com/admin/ 然后使用github Oauth登录即可看到：\n\n![](/images/uploads/2019-11-24-netlify-home.png)\n\n![](/images/uploads/2019-11-24-netlify-create.png)\n\n新增文章后， 你会发现github 上的source目录下的_post 目录的markdown 文件新增了，如果上传了图片，也会看到source目录下多了images/upload目录，同时https://troyyang.netlify.com 和 https://troyyang.com 下也自动发布了新的文章, 两者都是因为Source分支里新增了文件导致的自动部署。\n\n![](/images/uploads/2019-11-24-netlify-file-structure.png)\n![](/images/uploads/2019-11-24-troyyang.png)\n![](/images/uploads/2019-11-24-netlify.png)\n\n### 问题\n当我尝试打开 https://troyyang.com/admin/ 使用github Oauth登录时，结果报错，而https://troyyang.netlify.com/admin/则没有：\n```\nFailed to load settings from /.netlify/identity\n```\n![](/images/uploads/2019-11-24-netlify-admin-error.png)\n\n我怀疑是因为https://troyyang.com是托管在github上，而不是netlify上导致的。\n\n\nEnjoy!\n","tags":["netlify"],"categories":["web"]},{"title":"AWS系列之使用无服务器架构你的网站","url":"/2018/12/16/aws_serverless/","content":"***\n### Serverless 有什么用啊？\nJason最近又出新想法了，想要做一个简单的用户管理系统，好的，没问题，不就是在服务器上安装数据库，部署好网站吗？可答案是no，他不是专业人员，我也不可能永远维护这个服务器，更重要的是服务器开着就要美刀啊，还不能停，怎么办？有没有可以不用服务器的网站，有啊，你自己的静态博客不就是只用到了s3或者github的静态页面托管吗？可是数据库呢，后台api呢？额，这个嘛。。。   \n\n好了，成功引出话题，要知道这是21世纪的云时代，只有你想不到，没有做不到的，这不，AWS早就提出了[Serverless](https://aws.amazon.com/cn/serverless/?nc1=h_ls)解决方案：S3 + GateWay API + Lambda + DynamDB，其中举例的一个天气的app架构：\n\n![image](https://images.troyyang.com/2018-12-16-Lambda-WebApplications.png)\n\n其中s3做静态页面托管，用户触发点击事件，调用Gateway API提供到接口，接口映射到Lambda服务端接口，Lambda再负责去处理和数据库相关到操作。整个过程不需要服务器，而且费用是极低的，按量付费，可扩展性也很强，基本做到可配置化。说了这么多，还是得用过才知道好不好。\n\n### 实现思路\n1. 服务端RestFull： Node express 实现RestFull API\n2. 创建lambda并上传服务端代码\n3. 配置API Gateway映射到lambda函数\n4. 客户端实现： Bootstrap 实现登录 和 管理页面\n5. 修改客户端api接口地址并上传至S3\n\n其中，到第三步的时候我们就已经创建好了一个完整的无服务器的 Restfull API，剩下的就是客户端调用了，客户端调用这个就可以是五花八门的了，这也不是本篇文章的重点。\n\n### 简单 RestFull 服务端实现\n服务端的实现和平时实现一个Node RestFull api的完全没有任何区别, 部分代码如下:\napp.js\n```\n'use strict';\n\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cors());\n\nlet contacts = require('./data');\n\napp.get('/api/contacts', (request, response) => {\n  if (!contacts) {\n    response.status(404).json({ message: 'No contacts found.' });\n  }\n  response.json(contacts);\n});\n\nconst hostname = 'localhost';\nconst port = 3001;\nconst server = app.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n\nmodule.exports = app\n\n```\n\n这一步做完，确保所有接口都能通过访问 localhost:3001/api/contacts\n\n![image](https://images.troyyang.com/2018-12-16-restful-success.png)\n\n### aws-serverless-express\n要使得上面的服务端代码能在lambda中允许，只需借助 npm 包[aws-serverless-express](https://github.com/awslabs/aws-serverless-express)\n\n在目录下新增 lambda.js文件\n```\n// lambda.js\n'use strict'\nconst awsServerlessExpress = require('aws-serverless-express')\nconst app = require('./app')\nconst server = awsServerlessExpress.createServer(app)\n\nexports.handler = (event, context) => awsServerlessExpress.proxy(server, event, context)\n```\n这也是为什么我们要在 app.js最后一行exports的原因\n```\nmodule.exports = app\n```\n此时，将所有文件包括node_module目录全部打包为.zip 文件为后面使用。\n### 创建 lambda\n#### 创建 IAM role\n创建 Lambda的IAM Role是必须的，他指定了当前lamda能访问到的资源有那些，从我们的列子中，我们需要用到DynamoDB, 同时为了方便debug，我们还需要用到cloudwatch服务 （这个对于查找问题非常有用）。\n\n登录aws console，打开 Service 找到 IAM ，再选择Roles，点击 create role 按钮 后如图，(第三步可选)：   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step1.png)   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step2.png)   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step4.png)   \n\n#### 创建 lambda 函数\n打开Service 找到lambda, 选择 create function：   \n![image](https://images.troyyang.com/2018-12-16-create-lambda.png)\n\n创建后，在代码输入种类中选择上传 .zip 文件：   \n![image](https://images.troyyang.com/2018-12-16-lambda-manage.png)\n\n将服务端代码整个打包 （注意一定要包括packages目录下的所有文件）然后上传，大小不能超过10m，如果超过了，可以在代码输入种类选择s3上传。上传完成后，指定入口文件（即在处理程序）为 lambda.handler， 此文件将会映射到 lambda.js文件，一般情况，如果上传的zip包不是很大，aws会自动列出zip项目目录可供在线编辑，但如果大了的化，比如好几兆，则有可能不会列出项目目录，每次修改又只能重新上传。\n\n![image](https://images.troyyang.com/2018-12-16-lambda-list-file.png)\n\n当然，如果node 代码里包括了一些环境变量，你也可以为 lambda 做一些环境变量的设置：\n\n![image](https://images.troyyang.com/2018-12-16-lambda-env.png)\n\n一切ok后，就可以测试了，关于lambda的测试，则相对还比较麻烦，我也是最近才稍微懂那么一点。\n#### 测试 lambda 函数\n\n在创建好的lambda 函数旁，点击配置测试事件按钮，在弹出对话框创建测试事件中选择创建新测试事件，在事件模板中选择 Amazon API Gateway AWS Proxy, 并给个测试名称，如图：\n![image](https://images.troyyang.com/2018-12-16-lambda-create-test.png)\n\n选择Amazon API Gateway AWS Proxy是因为我们的这个lambda函数最终会被API Gateway 触发调用，同时由于默认的事件模板是 post 的请求方式，而我们的这个服务端只有一个api/contacts的get方法，所以我们需要更改事件内容为：\n```\n{\n  \"resource\": \"/{proxy+}\",\n  \"path\": \"/api/contacts\",\n  \"httpMethod\": \"get\",\n  \"headers\": {\n    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n    \"Accept-Encoding\": \"gzip, deflate, sdch\",\n    \"Accept-Language\": \"en-US,en;q=0.8\",\n    \"Cache-Control\": \"max-age=0\",\n    \"CloudFront-Forwarded-Proto\": \"https\",\n    \"CloudFront-Is-Desktop-Viewer\": \"true\",\n    \"CloudFront-Is-Mobile-Viewer\": \"false\",\n    \"CloudFront-Is-SmartTV-Viewer\": \"false\",\n    \"CloudFront-Is-Tablet-Viewer\": \"false\",\n    \"CloudFront-Viewer-Country\": \"US\",\n    \"Host\": \"1234567890.execute-api.ap-northeast-1.amazonaws.com\",\n    \"Upgrade-Insecure-Requests\": \"1\",\n    \"User-Agent\": \"Custom User Agent String\",\n    \"Via\": \"1.1 08f323deadbeefa7af34d5feb414ce27.cloudfront.net (CloudFront)\",\n    \"X-Amz-Cf-Id\": \"cDehVQoZnx43VYQb9j2-nvCh-9z396Uhbp027Y2JvkCPNLmGJHqlaA==\",\n    \"X-Forwarded-For\": \"127.0.0.1, 127.0.0.2\",\n    \"X-Forwarded-Port\": \"443\",\n    \"X-Forwarded-Proto\": \"https\"\n  }\n}\n```\n保存测试事件，并点击执行，如果一切正常，会得到如下:\n![image](https://images.troyyang.com/2018-12-12-lambda-test-success.png)\n\n### 创建 API Gateway\n找到Service下到API Gateway，并点击新建 api,   \n\n![image](https://images.troyyang.com/2018-12-16-create-api-gateway.png)   \n新增 api 资源（路径）   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-api-source.png)   \n选择 api 资源，再新增子资源，并选为proxy   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-source.png)   \n选择 proxy 资源，创建 集成环境为我们创建好的lambda 函数   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-method.png)   \n\n创建完成之后，在操作选项中，选择部署，弹出对话框并命名为dev阶段：   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy.png)   \n\n部署完成后，得到如下结果：   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy-success.png)\n\n### API Gateway 测试\n在部署完成后，我们会在上述结果中得到发布出来的api 地址为  \n>https://ijihnuupmh.execute-api.ap-northeast-1.amazonaws.com/dev\n\n此时如果直接访问，会得到Missing Authentication Token的错误，原因是我们地址不对\n```\n{\"message\":\"Missing Authentication Token\"}\n```\n正确地址应该为:\n>https://ijihnuupmh.execute-api.ap-northeast-1.amazonaws.com/dev/api/contacts\n\n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy-url-success.png)   \n\n由于上述地址是永久的，除非你重新部署，所以我们可以放心的使用用来作为api地址。还有一个就是API Gateway似乎是不收取费用的，只会按照lambda\b函数的调用\b次数来收取费用，好像每月前100万次请求是免费的。\u001c所以还是相当划算。\n\nOK! 一个无服务器的后端 api 就这样搭建好了，剩下的就是前端静态资源的托管了\n\n### 前端静态资源\n\b直接上传html,js,css 等静态资源到S3就好了，具体可以参见另一篇博客 [AWS系列之S3 + Cloudfront搭建https静态网站](https://troyyang.com/2018/05/12/aws_s3_https_static_website/)\n\n","tags":["serverless"],"categories":["aws"]},{"title":"AWS系列之S3 + Cloudfront搭建https静态网站","url":"/2018/05/12/aws_s3_https_static_website/","content":"***\n\n本文和之前写的[《正确使用AWS S3的方式之打造自己的https图床》](https://troyyang.com/2018/02/16/hosting-images-with-aws-s3/) 内容非常像，但也有新的内容如自动上传部署和自定义证书、Route53部分，这里主要补充新的内容。\n\n### 温馨提醒\n1. 个人用户请注册AWS 全球账号，因为AWS 中国账号似乎只对企业开发而无法注册。\n2. AWS S3默认地址中国无法访问，需要使用Cloudfront的新地址才能访问，而且访问速度不慢，你能感觉到我博客的图片加载慢吗？\n3. S3、Cloudfront、Route53等收费异常的低，几乎可以忽略。\n\n### 架构概述\n![image](https://images.troyyang.com/2018-5-12-myenglishtutor-s3.png)\n采用Hexo作为静态网站生成器，主题使用的正是我自己开发的hexo-theme-twentyfifteen-wordpress，整个网站代码托管在github的私人repo下。当写好文章后，使用Hexo生成静态代码html+css+js+image，并使用写好的s3 SDK 上传工具到指定aws 的存储桶里进行静态托管 （之前使用的是github的Travis 自动部署，但由于私人Repo需要收费，于是放弃Travis改用自己的工具上传）。上传到S3里之后，使用Cloudfront做内容分发，并绑定自定义的https证书，最后，使用Route53做自定义域名的绑定。\n\n### 生成 IAM access key 用户子账号 \n此账号可用于编程的方式访问AWS 的所有指定资源，这里我们创建的IAM 账号只需要有S3的读写权限\n\n进入 https://console.aws.amazon.com/iam/home?region=ap-northeast-1#/users\n\n选择add user后， 一定要选择programmatic access这种编程方式的子账号，而另一个console账号针对的是用户名，密码登录的子账号\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step1.png)\n\n指定该账号可访问的权限\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step2.png)\n\n保存access id和key\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step4.png)\n\n### 使用S3 SDK自动上传\n默认情况下，所有Hexo编译后的文件都放在public文件件下，所以只需要拷贝到S3 存储桶下，当然可以手动拷贝，但是实在太麻烦。所以写了个node tool去自动上传（部署）。\n\n[下载](https://gist.github.com/Troy-Yang/436a62fb14d9e07e1aa3534f1c351050)\n--s3-deploy\n------config.json\n------index.js\n\nconfig.js 里包括的是AWS AMI 账号信息，确保region使正确的区域, 具体参考[区域列表](https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)\n```\n{\n    \"accessKeyId\": \"xxxxxx\",\n    \"secretAccessKey\": \"xxxxx\",\n    \"region\": \"ap-northeast-1\" \n}\n```\n\nindex.js，其中myenglishtutor.eu是存储桶的名字(命名的时候请用域名)\n```\nvar path = require(\"path\");\nvar fs = require('fs');\nvar mime = require('mime');\nvar AWS = require('aws-sdk');\nAWS.config.loadFromPath('./s3-deploy/config.json');\nlet s3 = new AWS.S3();\n\nconst uploadDir = function (s3Path, bucketName) {\n    function walkSync(currentDirPath, callback) {\n        fs.readdirSync(currentDirPath).forEach(function (name) {\n            var filePath = path.join(currentDirPath, name);\n            var stat = fs.statSync(filePath);\n            if (stat.isFile()) {\n                callback(filePath, stat);\n            } else if (stat.isDirectory()) {\n                walkSync(filePath, callback);\n            }\n        });\n    }\n\n    walkSync(s3Path, function (filePath, stat) {\n        let bucketPath = filePath.substring(s3Path.length + 1);\n        let mimeType = mime.getType(bucketPath);\n        let params = { \n            Bucket: bucketName, \n            Key: bucketPath.replace(/\\\\/g, '/'), \n            Body: fs.readFileSync(filePath),\n            ContentType: mimeType\n        };\n        s3.putObject(params, function (err, data) {\n            if (err) {\n                console.log(err)\n            } else {\n                console.log('Successfully uploaded ' + bucketPath + ' to ' + bucketName);\n            }\n        });\n    });\n};\n\nuploadDir(\"public\", \"myenglishtutor.eu\");\n```\n\n最后在package.json文件中，添加运行脚本：\n```\n  \"scripts\": {\n    \"start\": \"hexo clear & hexo g & hexo server\",\n    \"deploy\": \"hexo clear & hexo g & node ./s3-deploy/index\"\n  },\n```\n\n### 使用Travis 自动部署\n如果代码是托管到github上或者支持Travis的服务，可以是用下面的.travis.yml配置达到CI, CD，请在travis.org中配置好环境变量$AWS_ACCESS_ID， AWS_SECRET_KEY，AWS_REGION\n```\nlanguage: node_js\nnode_js: stable\n\nscript: true\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n\nbefore_install:\n  - git submodule update --init --remote --recursive\n  \n#before_script:\n # - npm install -g gulp\n\nscript:\n  - hexo g\n# E: Build LifeCycle\n\n\nbefore_deploy:\n  # - zip -r latest *\n  # - mkdir -p dpl_cd_upload\n  # - mv latest.zip dpl_cd_upload/latest.zip\n  - cp -a source/.well-known public/\n\ndeploy:\n  - provider: s3\n    access_key_id: ${AWS_ACCESS_ID}\n    secret_access_key: ${AWS_SECRET_KEY}\n    local_dir: public\n    skip_cleanup: true\n    on:\n      repo: Troy-Yang/troy-yang.github.io\n      branch: source\n    bucket: troyyang.com\n    region: ${AWS_REGION}\n```\n\n### https自定义证书\n想要支持https，那么证书是必须的，可以直接开启cloudfront，默认就会添加cloufront生成证书，如\n![image](https://images.troyyang.com/2018-2-18-distribution-overview.png)\n\n如果想要自定义证书，则需要自己在ACM(AWS Certificate Manager)申请证书，并做txt域名验证，一切ok后则会得到：\n![image](https://images.troyyang.com/2018-5-12-aws-myenglishtutur-acm.png)\n\n申请步骤如下：\n进入 https://console.aws.amazon.com/acm/home?region=us-east-1#/wizard/ \n填写域名:\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step1.png)\n选择验证方式：（DNS验证方便，Email没试过，好像很麻烦）\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step2.png)\n拷贝name和value值，保存并在DNS服务器中添加CNAME记录，如果DNS是使用AWS自家的Route53，则非常方便，只需要在相应的Domain下，添加 Record Set 记录, 类型选择CNAME。如果是在万网或者Cloudflare，也是非常方便的。\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step4.png)\n记录添加好后，等待验证通过后（大概几至十几个小时后），状态从pending 变为 issued，就说明证书通过，该域名已合法。\n![image](https://images.troyyang.com/2018-5-12-aws-acm-list.png)\n\n#### Cloudfront 中使用自定义证书\n证书有了之后，只需要将其添加到创建的Cloudfront中就可以了\n![image](https://images.troyyang.com/2018-5-13-aws-acm-cloudfront.png)\n\n请注意选择Custom SSL Certificate, 然后输入框中，AWS会自动列出可用的证书列表，如果没有，则点击Request or Import a certificate with ACM 选择上面新增的就好了\n在浏览器访问这个cloudfront地址，就可以看到https的标志，查看这个https证书就可以得到自定义的这个域名，而不是cloudfront开头的，看起来是不是很高大上。\n\n#### 绑定Cloudfront 到自定义DNS\n上面的cloudfront地址如果用于提供API之类的接口地址倒是无所谓， 但是如果是别人访问的地址，那肯定不行的，还需要添加一条A记录，将自己的域名和上述地址进行绑定。同理，如果是在Route53，只需要添加一条A记录就好了，大致如图：\n![image](https://images.troyyang.com/2018-5-13-aws-dns-cloudfront.png)\n\n保存后，过几分钟就可以通过自己域名，访问到S3中的内容，并且证书显示的是自己域名。\n![image](https://images.troyyang.com/2018-5-12-aws-myenglishtutur-acm.png)","tags":["aws"],"categories":["aws"]},{"title":"AWS系列之 myenglishtutor基于AWS生态的广泛使用","url":"/2018/05/12/aws_structure_series/","content":"***\n### 写在开头\n看着系统生成的写作时间，2018年5月12日，恐怕是让所有四川人都难以忘怀的日子，在此缅怀十年前大地震遇难的同胞，也希望曾遭受苦痛的同胞十年后的今天一切安好！\n\n回想在给Jason兼职工作的这半年多，一个人把 ![image](https://myenglishtutor.eu/images/icons/favicon-32x32.png) [https://myenglishtutor.eu](https://myenglishtutor.eu) 从0到1的把网站一点一点建好，感觉像个自己的孩子，总想要给他最好的，但也由于个人精力有限，很多想做的都没去做。尤其是AWS的生态让我印象深刻，所以想要写下这一个系列的技术感悟。\n\n|<h2>[AWS系列之S3 + Cloudfront搭建https hexo静态网站](https://troyyang.com/2018/05/12/aws_s3_https_static_website/)</h2>|\n|:---------|\n|使用hexo做静态内容生成，s3托管静态网站内容，使用cloudfront做内容分发及https证书自动生成，route53做域名DNS解析，还有部分工具如依托s3 SDK做代码自动上传部署，google driver 自动同步等。|\n|hexo、s3、cloudfront、route53、certification、aws s3 SDK auto sync file and deployment|\n\n|<h2>[AWS系列之 Stripe 国际支付](https://troyyang.com/2018/01/21/stripe_guide_alipay/)</h2>|\n|:---------|\n|服务端使用Lambda、API Gateway实现的无服务器服务，客户端使用Stripe的Element.js类库|\n|Lambda、API Gateway|\n\n|<h2>AWS系列之结合OpenTek实现多人实时Web视频通话、教学</h2>|\n|:---------|\n|使用s3做视频前端和后台管理的代码托管, Lambda+DynamoDB+API Gateway实现Serverless搭建的node express无服务器服务端。|\n|s3、openTek SDK、Lambda、DynamoDB、API Gateway、Angular 1.0、bootstrap|\n\n|<h2>AWS系列之Polly服务实现AI文本到语音翻译</h2>|\n|:---------|\n|使用aws的Polly服务实现文本转语音的翻译，服务端搭建的Serverless服务端，客户端使用自己写的hexo plugin功能调用API。|\n|Lambda、API Gateway、SNS、s3、Hexo plugin|\n\n|<h2>AWS系列之使用Wowza streaming实现视频直播+弹幕服务</h2>|\n|:---------|\n|架构上使用EC2负载均衡和自动扩容实现可伸缩视频直播服务。弹幕使用web socket实现双向通信，客户端采用对手机H5播放支持。|\n|s3、EC2、Load banance、ASG、cloudfront、linux、 danmaku、h5 video|\n\n\n这里也打个广告简单介绍一下Jason和他的myenglishtutor，从名字也大概知道他是个英语老师和他的个人网站，Jason是个地道的英国人，浓厚的英国口音以及超过十几年英语专业教学经验，作为myenglishtutor的开发者，我为他集成了包括视频直播，1对1，1对多的视频教学直播，支付宝支付，词法解释等功能，所以不用担心教学方式及支付等问题。如果有意专业英语要求的个人或者团体，欢迎直接联系我，有更低的折扣等你。\n\n","tags":["aws"],"categories":["aws"]},{"title":"正确使用AWS S3的方式之打造自己的https图床","url":"/2018/02/16/hosting-images-with-aws-s3/","content":"***\n\n写过博客的人都知道图床，一个托管自己博客图片的地方，当然托管到自己的服务器另当别论。常见的图床可以是新浪博客，七牛云，imgur等，但是都是有各种问题，比如我之前使用的是七牛云（也曾在[《给Github自定义域名加上HTTPS》](https://troyyang.com/2017/05/21/Add_Free_Certification_In_Blog_Step_By_Step/)博文上推荐使用），用起来相当不错，只可惜后来备案信息过期了，导致无法再使用自定义域名，更可悲的是，https不再支持，意味着尽管我的博客是https但由于有内容是http的，只能被浏览器认为是mixed-content的。\n\n但是，前几天无意发现一片新大陆，使用aws s3结合cloudfront distribution 可以借助亚马逊云无缝快速托管自己的图片还自带https，而费用几乎是很小的，按量收费。\n\n### 步骤概述\n（如果不需要有自定义图片的域名，第三步可选）\n1. 创建一个图片s3 bucket并公开。\n2. 创建cloudfront distribution并绑定S3 bucket和默认证书以支持https\n3. 在DNS服务商（我的是cloudflare）创建图床域名，并绑定cloudfront域名地址 \n\n### 全球亚马逊 Or 亚马逊中国？\n两者区别好像挺大的，后者曾经注册过，但是不知为什么没通过审核，可能需要公司邮箱吧。并且，如果考虑到备案等因素，建议使用全球亚马逊。（需要绑定VISA信用卡）   \n全球亚马逊地址是：https://console.aws.amazon.com/console/home\n\n### 创建S3 Bucket（存储桶）\n账号创建成功后，进入S3控制台https://s3.console.aws.amazon.com，存储桶名称以待托管域名命名，比如我的是 images.troyyang.com，其他项首先都选择默认，待会再一项一项改。\n![image](https://images.troyyang.com/2018-2-18-s3-bucket.png)\n#### 访问权限设置\n\n在存储桶的权限页面，选择存储桶策略，键入下面的值：\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"PublicReadForGetBucketObjects\",\n            \"Effect\": \"Allow\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::images.troyyang.com/*\"\n        }\n    ]\n}\n```\n![image](https://images.troyyang.com/2018-2-18-aws-s3-permission.png)\n#### 静态托管\n存储桶创建成功后，进入属性页面，选择静态网站托管，键入索引文件index.html，错误文档error.html，然后保存。此时，公共访问页面已经生成，终端节点如下：\nhttp://images.troyyang.com.s3-website-ap-northeast-1.amazonaws.com\n\n![image](https://images.troyyang.com/2018-2-18-aws-s3-static-host.png)\n上传自己的所有图片在此存储桶下，然后加上文件后缀就应该可以访问了，然而现实是残酷的，在我大天朝下，这个地址有时候是无法访问当的 。。。WTF。。。于是，得进行下面的自定义域名步骤\n\n### CloudFront Distribution\n上面地址是AWS自动生成的访问域名，并且只支持http，想要支持https，并且绑定自定义域名（images.troyyang.com），需要使用到CloudFront Distribution。\n\nCloudFront Distribution 是AWS的内容分发（CDN）使得全球各地都能以最快的速度访问到AWS最近的节点（对于中国，最近的是东京，经测，也已经足够快），并且可绑定或者生产SSL证书。\n\n#### 创建 Distribution\n打开 https://console.aws.amazon.com/cloudfront/home， 选择Create Distribution, 传输方式选择Web选项 Get Started，在很多选项中，主要注意几项就好了（都是可后期修改）：\n- Origin Domain Name中选择刚才所建的S3 Bucket 域名\n- Alternate Domain Names(CNAMEs)填写自定义域名(没有的话，可不管)， 这里是 images.troyyang.com\n- SSL Certificate 暂时选默认Default CloudFront Certificate (*.cloudfront.net)\n- Price Class 可以只选择Use Only US, Canada, Europe and Asia\n\n![image](https://images.troyyang.com/2018-2-18-aws-create-distribution.png)\n\n一切配置好后，静静等待几个小时就会看到Distribution部署成功，大致结果如下：\n\n![image](https://images.troyyang.com/2018-2-18-distribution-overview.png)\n\n此时，得到Distribution 的新访问地址 d2dxo9yo9kwqp2.cloudfront.net，这个时候，我们找一张在S3中存在的图片，加上https再次访问 https://d2dxo9yo9kwqp2.cloudfront.net/2017-5-21-https.png 一切OK\n\n#### 自定义证书（可选）\n上面的证书是亚马逊自己提供，如果想要使用绑定自己的域名证书，可以使用AWS的Certificate Manager 证书服务，在自己的DNS服务商比如万网或者阿里云那里配置好验证方式，具体操作方法参考 https://docs.aws.amazon.com/zh_cn/acm/latest/userguide/gs-acm-request.html 。因为我暂时觉得没必要，所以没使用上。\n\n### 绑定自定义域名（可选）\n上面的是cloudfront分发的一个地址，虽然地址是固定的，但毕竟不是自家的域名，感觉不高大上，所以需要绑定上自己的图片域名。\n\n由于我的DNS服务解析改为了Cloudflare，所以是以Cloudflare的来配置的域名，但和万网或者阿里云的配置完全一致，在DNS解析项中添加一条CNAME记录，指向Cloudfront分配的域名即可\n\n![image](https://images.troyyang.com/2018-2-18-dns-image.png)\n等待绑定解析成功后，访问 https://images.troyyang.com/2017-5-21-https.png ，一切OK\n","tags":["s3"],"categories":["aws"]},{"title":"Stripe开发使用指南--国际支付（含支付宝）","url":"/2018/01/21/stripe_guide_alipay/","content":"***\n前段时间，因为Jason让我帮忙把Stripe支付集成到他个人网站上去，让我有机会接触到支付系统开发，同时也因为苦于没有找到太多中文方面相关文档介绍，所以做个总结，也方便以后有需要的同学。   \n(更新) 2021.5 发现好些同学也在咨询如何集成微信支付，其实也是非常简单，所以新增了最后微信的实现，见最后 \n(更新) 2022.8 Source的方式已经不被推荐，推荐使用PaymentIntent\n\n### 关于Stripe支付\n\n第一次听说Stripe还是在几个月前的一个新闻上了解到，大致说的是美国总统都在使用它，极有可能成功下一个Paypal。这么受欢迎的一个支付平台到底有什么好处呢？我粗略搜集了一下：\n\n- 一条代码让你网站支持繁琐的国际支付功能。（对于创业公司，再合适不过）\n- 向全球化业务拓展会成为Stripe的机会。即使支付货币不同、方法不同，Stripe都能打通各自的渠道，让全球化交易不受支付阻碍。\n- 市值超过90亿美元，和Tweeter,Lyft，Best Buy等以及国内的 Alipay, WeChat等有合作\n\n重点说下第二点，什么意思呢，就是说客户可以使用人民币支付，如果商家（收款方）是美国的银行的话，就自动转成美元，是英国的银行就自动转为英镑！（**可惜暂时不支持商家是中国（但Stripe也可提供解决方案，就是使用Atlas去创建一个美国的代理公司）**）\n\n而对于我们程序员的话，当然最关心第一条，因为他的宗旨就是开发极简，对开发人员超级友好！至于多友好呢，请往下看。\n\n### 最简洁支付\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Stripe Checkout</title>\n</head>\n<body>\n   <form action=\"/your-server-side-code\" method=\"POST\">\n  <script\n    src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"\n    data-key=\"[Publishable key]\"\n    data-amount=\"999\"\n    data-name=\"troy yang\"\n    data-description=\"Widget\"\n    data-image=\"https://stripe.com/img/documentation/checkout/marketplace.png\"\n    data-locale=\"auto\"\n    data-zip-code=\"true\"\n    data-currency=\"eur\">\n  </script>\n</form>\n</body>\n</html>\n```\n就这么几行代码，我们就已经实现了客户端所有事：\n\n![image](https://images.troyyang.com/2018-1-13-stripe-checkout.png)\n\n真的是超级简单，但是这种方式是基于信用卡支付的界面，已经可以满足一半的支付方式，对于其他的三方支付，比如3D secure， 支付宝，微信，甚至比特币，Stripe为我们提供了其他方式，等下我就使用支付宝来举例。\n\n### 注册 Stripe 账号\n和注册支付宝账号一个道理，首先注册账号，然后绑定自己银行卡，BUT, 就像前面提到的，不支持中国，所以就算注册成功，也没法激活，也就没法收款。\n![](https://images.troyyang.com/2018-1-13-stripe-support-countries.PNG)\n\n对于中国商家怎么办呢，我能想到的就只有这几个办法：\n- 自己去支持国家去办理张银行卡\n- 使用国外的朋友银行卡\n- 使用Atlas\n\n对于Jason来说，因为他是英国人，所以他可以创建他的主账号，然后添加我的stripe账号到他team memeber账号列表中，这样我就可以访问他账户下所有开发者需要的权限。邀请成功后，Dashboard页面\n\n### 两个阶段\n\nStripe有两种模式，一个是测试模式(Test Mode)，一个是生产模式(Live Mode)，测试模式下产生的金钱交易都只用于测试，当所有测试通过后即可切换为Live模式。唯一的不同就是**Publishable key** 和 **Secret key**， 一会我们会用到这两个值。\n![image](https://images.troyyang.com/2018-1-13-stripe-test-mode.PNG)\n\n### 交易流程\nStripe有几个概念用于整个交易阶段和状态：\n![image](https://images.troyyang.com/2018-1-18-workflow.png)\n\n#### 创建 Source\n\n使用自己的**Publishable key**来创建一种source（比如Cards, 3D Secure, 支付宝，甚至比特币等）, 创建source完了后，就会得到一个用于交易的Token或者是一个跳转到其他支持的三方支付平台（比如支付宝支付）页面等待用户支付。当用户支付（或者取消支付）完成，自动跳转回到指定结果页面。用户支付页面结束后，可能会得到三个状态：\n\n- source.chargeable 用户授权（支付）成功\n- source.failed 用户拒绝授权（支付）\n- source.canceled 超时支付\n\n#### 创建 Charge\n当用户支付成功后，此时在Stripe端的支付状态变为source.chargeable，意思就是授权成功了，你可以在我支付宝平台上扣钱啦，所以，此时我们还需要使用**Secret key**来创建Charge来完成，官方推荐的是使用webhooks来捕捉状态，并且完成Charge的创建。当Charge完成后，整个支付完成，会得到一个charge.succeeded的状态。\n\n#### 使用 webhooks\nWebhooks 里提供了几十种状态，所有这些状态都会注册到Stripe里一个叫webhooks事件钩子的地方，我们可以指定不同事件的触发时，转发数据到某个我们自己搭建好的Web Api上。（下图是我们的服务器end point, 因为我们没有用到服务器，使用的是亚马逊lambda做一个Serverless）\n![image](https://images.troyyang.com/2018-1-18-web-hooks.png)\n\n## 举个支付宝的栗子\n\n### 服务端 （Serverless）\n以AWS的Lambda + API gateway为例， 其中，前者是用来定义API， 后者是做路由。\n![image](https://images.troyyang.com/2018-1-18-lambda.png)\n\n![image](https://images.troyyang.com/2018-1-18-lambda-source-chargeable.png)\n\n![image](https://images.troyyang.com/2018-1-18-lambda-variable.png)\n\n创建Charge代码：\n```\n'use strict';\n\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\nexports.handler = (event, context, callback) => {\n    console.log(\"request: \" + JSON.stringify(event));\n\n    let stripeData = event.data.object;\n    stripe.charges.create({\n        amount: stripeData.amount,\n        source: stripeData.id,\n        currency: stripeData.currency || 'usd',\n        description: 'My Englishtutor 30 days' || ('Stripe payment ' + event.id),\n    }, function(err, charge) {\n        if (err && err.type === 'card_error') {\n            context.fail(new Error(err.message));\n        }\n        else if (err) {\n            context.fail(err);\n        }\n        else {\n            context.succeed({ status: charge.status, success: true });\n        }\n    });\n};\n```\n\n\n### 客户端 (Web)\n多种实现方式：\n#### Checkout\n文章开头那段<form>的集成代码就是使用的checkout方式，非常简单。集成代码直接帮你完成了客户端的部分，服务端只需要定义好source.chargeable的钩子API 就好了。\n\n在做支付宝开发的时候，发现可以直接使用Checkout的方式：\n```\n<form action=\"https://xxx.execute-api.eu-central-1.amazonaws.com/stripepayment/xxx\" method=\"POST\">\n  <script\n    src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"\n    data-key=\"pk_test_xxx\"\n    data-amount=\"30000\"\n    data-name=\"myenglishtutor.eu\"\n    data-label=\"Pay With Alipay\"\n    data-description=\"30 days\"\n    data-image=\"/images/logo.png\"\n    data-locale=\"auto\"\n    data-alipay=\"auto\"\n    data-currency=\"usd\">\n  </script>\n</form>\n```\n但是总是得到这个错误：\n```\nUnrecognized request URL (POST: /v1/alipay/send_sms). Please see https://stripe.com/docs or we can help at https://support.stripe.com/.\n```\n![image](https://images.troyyang.com/2018-1-21-alipay-checkout.png)\n\n发邮件给Stripe support team得到的结果是为了以后的扩展，Stripe不再提供alipay的checkout方式， 无奈，只得使用下面的方式。\n#### Stripe.js & Elements\n当然对于如果你觉得Checkout的方式集成度太高，不够灵活，那Stripe.js是你最好的选择。\n\nStripe.js其实就是客户端的一个JS核心类库，Elements是它的UI类库，其实上面的Checkout代码就是Stripe使用两者给我们封装好了的，避免我们直接接触敏感信息，但是其实质都是一样的，都是用来创建source。这里就直接贴出客户端的代码了(这里没有用到Elements做UI，因为就是一个按钮支付，太简单，所以没用到)：\n```\nvar stripe = Stripe('pk_live_xxxx');\n\nfunction alipay(amount) {\n    showLoading();\n    stripe.createSource({\n        type: 'alipay',\n        amount: parseInt(amount),\n        currency: 'gbp', // usd, eur,\n        redirect: {\n            return_url: 'https://xxx.eu/pay/result.html'\n        },\n    }).then(function (response) {\n        hideLoading();\n        if (response.error) {\n            alert(response.error.message);\n        }\n        else {\n            processStripeResponse(response.source);\n        }\n    });\n}\n\nfunction processStripeResponse(source) {\n    window.location.href = source.redirect.url;\n}\n```\n![image](https://images.troyyang.com/2018-1-21-alipay-console.png)\n\n\n这里需要注意几点：\n- currency 必须是Stripe账号所在地货币，也就是绑定的银行卡所在地，因为Jason是英国人，所以必须使用gbp（这里愚蠢如我的犯了一个常识错误，一直以为英国也是欧盟的，所以使用eur，结果怎么也不对，直接哭晕在厕所）\n- return_url指向的是当用户重定向到我们常见的支付宝支付页面后，跳转回支付完成的页面，在这个返回页面中，因为支付宝是同步完成支付的，所以我们可以去查询charge.succeeded的状态来判定是否用户支付是否完成。\n\n\n当一切OK，点击支付按钮，就会跳转到支付宝支付页面(其他支持的三方平台也可以)，如下：\n![image](https://images.troyyang.com/2018-1-23-alipay-success.png)\n\n### 微信实现\n其实也非常的简单，只需要将上一步的type改为wechat，同时返回source中的source.wechat.qr_code_url转为二维码就好了\n```\nvar wechatCallback = function (source) {\n    generateQRCode(source.wechat.qr_code_url);\n}\nfunction generateQRCode(value) {\n    var qrEle = document.getElementById(\"qrcode\");\n    var qrcode = new QRCode(qrEle, {\n        width: 100,\n        height: 100\n    });\n    qrcode.makeCode(value);\n    qrEle.style.display = 'inline-block';\n}\n```\n二维码出来后， 扫码就会得到如下结果   \n![image](https://images.troyyang.com/2018-12-16-wechat-success.jpeg)  \n\n(更新) 本人开发了一款wordpress stripe插件，主要针对微信和支付宝，涉及一些更新，详见另一篇文章[Wordpress 插件 Stripe Express 发布啦!](https://troyyang.com/2020/12/30/wordpress-stripe-express-released/)\n","tags":["finance"],"categories":["Web"]},{"title":"成都持续交付大会","url":"/2017/12/10/cdconf/","content":"抽空记录一下2017年11月18日中国第十三届持续交付大会的内容，总的来说收货满满，扫盲了很多持续集成，持续交付以及众多分布式相关的技术。\n\n![image](https://images.troyyang.com/2017-11-18-cdconf.png)\n\n\n## 关键点\n### 微服务架构\n微服务毫无疑问是这两年最火的架构模式之一，可惜没有机会实践，但是了解到的是重点在于如何划分服务，更多的可以参考[cnblogs](https://www.cnblogs.com/imyalost/p/6792724.html)上的一篇博文，很全。\n![image](https://images.troyyang.com/2017-11-18-microservices.png)\n\n### 京东架构演变\n听完演讲者的京东架构演变的过程充分验证了金字塔不是一天建成的，互联网产品一直是迭代的，两张京东架构图足以说明他们的技术演变过程：\n\n**架构1.0:**\n![image](https://images.troyyang.com/2017-11-18-jd-v1.png)\n\n**架构3.0:**\n![image](https://images.troyyang.com/2017-11-18-jd-v3.png)\n\n### Serverless\n感觉Serverless 会是另一个未来软件开发的趋势，自己的博客系统里就集成了很多serverless的服务，对于我来说最常见的可能就是类似各种评论系统像DISQUS，多说, （哎，可惜已经关了），存储系统等。当然对企业来说的话，像亚马逊的Lambda这种更能方便客户快速拼接出各种产品，减少开发人员成本。\n\n这个月也参加了亚马逊用户社区活动，里面更是重点提到了Serverless的广泛运用，听完更是为Severless 打call。\n\n## 扫盲篇（未完）：\n\n### elasticsearch\n### jmq\n### binlog\n### 数据库分库分表（取模）\n### jproxy\n### 服务找寻（取模）\n### TRUNKED BASED DEVELOPMENT\n### A/B 测试\n### 蓝绿部署\n### 分布式调用链追踪原理：在相互每个服务请求header中添加trackId\n### 契约测试框架：janus, pact, pacto, spring cloud contract\n### 开发环境区分：dev-qa-sys-perf-uat-prod (我们公司使用的有点不一样localdev-stage-dev-qa-uat-prod)\n\n","tags":["devops"],"categories":["笔记"]},{"title":"Linux下Apache反向代理搭建SSL + Node 服务配置","url":"/2017/11/26/linux_apache_ssl_node/","content":"***\n\n## SSL 配置\n### 证书申请 \nCloudflare生成证书key pair 的pem 格式文件，更名为.crt和.key。文件名和扩展名只是为了提供便利，对功能没有影响；你可以将证书命名为 cert.crt、cert.pem 或 任何其他文件名。\n### 拷贝证书\n使用winSCP 拷贝文件至etc/pki/目录,其中.crt拷贝至etc/pki/tls/certs, .key拷贝至etc/pki/tls/private下。 （由于使用AWS的EC2服务器，拷贝时没有对pki的写权限，所以执行了下面语句将ownship权限赋予ec2-user）\n```\nsudo chown -R -v ec2-user /etc/pki/\n```\n### Linux Apache配置\n安装Apache 模块 mod_ssl 来添加 SSL/TLS 支持\n```\nsudo yum install -y mod24_ssl\n```\n这个时候检查/etc/httpd/conf.d/ssl.conf，你会发现默认的localhost（self-signed）证书已经配置好了。\n这里使用自己的证书，修改Apache配置文件 ssl.conf 中的 配置项\nSSLCertificateFile /etc/pki/certs/test.cer\nSSLCertificateKeyFile /etc/pki/private/test.key\n\n上面的修改是全局的，会对所有站点起作用，如果只布置某个站点，则需要在制定站点的配置里添加下面的配置就好了。找到或创建自己的apache配置文件，可能是/etc/httpd/conf/httpd.conf 或者/etc/httpd/conf.d/ 下默认的xx.conf文件，这里我重新创建一个新的配置以作为我站点的配置文件：\n```\nNameVirtualHost *:443\n<VirtualHost *:443>\nDocumentRoot   /var/www/where\nServerName     where.troyyang.com\nSSLEngine      on\nSSLCertificateFile        /etc/pki/tls/certs/where.troyyang.com.crt\nSSLCertificateKeyFile     /etc/pki/tls/private/where.troyyang.com.key\n</VirtualHost>\n```\n\n### 测试\n\n## 安装[nodejs](https://nodejs.org/en/download/package-manager/)\nOn RHEL, CentOS or Fedora, for Node.js v6 LTS:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -\nsudo yum -y install nodejs\nsudo yum install gcc-c++ make\n```\n\n### Node 测试\n在/var/www/where目录下创建test.js文件\n```\nvar http = require(\"http\");\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(1337);\n```\n\n### Apache 反向代理配置\n```\n<VirtualHost *:443>\n    ServerAdmin admin@site.com\n    ServerName where.troyyang.com\n    SSLEngine      on\n    SSLCertificateFile        /etc/pki/tls/certs/where.troyyang.com.crt\n    SSLCertificateKeyFile     /etc/pki/tls/private/where.troyyang.com.key\n    ProxyRequests off\n    <Proxy *>\n        Order deny,allow\n        Allow from all\n    </Proxy>\n\n    <Location />\n        ProxyPass http://localhost:8080/\n        ProxyPassReverse http://localhost:8080/\n    </Location>\n</VirtualHost>\n```\n重启apache\n```\nsudo httpd -k restart\n```\n启动node\n```\nsudo su root \ncd /var/www/where/\nnode test.js\n```\n浏览器浏览https://where.troyyang.com，输出hello world! 但是一旦退出当前连接session比如putty，则服务停止，所以需要让node服务在后台运行，这里可以使用[forever](https://www.npmjs.com/package/forever)包\n```\nsudo npm install -g forever\ncd /var/www/where/\nforever start test.js\n```\n\n###　部署服务\n- 拷贝源码\n\n```\ncd /var/www/where/\nnpm install\nNODE_ENV=development node app/server.js\n```\n如果用forever\n```\ncd /var/www/where/\nnpm install\nforever stopall\nforever list\nforever start app/server.js NODE_ENV=development\nforever list\n```\n\n>一定要注意Node源码中require的包一定是大小写敏感的，因为Unix系统是文件名大小写敏感，这和Windows系统不一样。就在这里载了个坑，有段代码是require('Joi')，但是找不到joi这个module包，改为require('joi')就对了。\n\n>如果第二次部署时（覆盖原来代码，运行node app/server.js），可能会遇到端口8080使用中，此时可以停用所有node监听端口，再运行\n```\nps aux | grep node\nkillall node\n```\n\n\n\n","tags":["web"],"categories":["笔记"]},{"title":"windows 下搭建https + node.js + nginx","url":"/2017/11/07/windows-ssl-node-nginx/","content":"***\n\n最近做一个微信小程序的时候因为要求所有请求都得是https的连接，服务器端https 倒是搭建好了，可本地测试没法进行啊，于是只能自己在本地搭建个https的服务。\n\n步骤很少，和把大象放进冰箱需要的步骤一样！只需要三步：\n第一步：要使用ssl，肯定需要生成证书，这里我就生成的自签名证书\n第二部：安装nginx和配置ssl\n第三部：用nginx反向代理到node服务端口\n\n\n## 证书生成\n### 安装Openssl\n\n1. 下载地址：http://slproweb.com/products/Win32OpenSSL.html\n（根据系统选择32位或者64位版本下载安装）。\n\n2. 下载完成后，进行安装，默认安装在 C:\\OpenSSL-Win64文件夹中。\n　　\n3. 配置环境变量。在环境变量中添加环境变量Path ：C:\\OpenSSL-Win64\\bin; \n### 自签名证书生成\n```\n> cd c:\\ssl\n// 设置变量\n> set OPENSSL_CONF=C:\\OpenSSL-Win64\\bin\\openssl.cfg\n> echo %OPENSSL_CONF%\n\n//生成server.key\n> >openssl genrsa -out server.key 4096\n\n//生成request文件\n> openssl req -new -key server.key -out server.csr\n\n//获取私钥\n> openssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\n```\n其中，server.crt就是我们的证书，server.key就是私钥。\n\n注意一定要设置变量OPENSSL_CONF不然会有以下错误\n\n```\nc:\\OpenSSL-Win64\\bin>openssl req -new -key server.key -out server.csr\nCan't open C:\\Program Files\\Common Files\\SSL/openssl.cnf for reading, No such file or directory\n6440:error:02001003:system library:fopen:No such process:crypto\\bio\\bss_file.c:74:fopen('C:\\Program Files\\Common Files\\SSL/openssl.cnf','r')\n6440:error:2006D080:BIO routines:BIO_new_file:no such file:crypto\\bio\\bss_file.c:81:\nEnter pass phrase for server.key:\nunable to find 'distinguished_name' in config\nproblems making Certificate Request\n6440:error:0E06D06A:configuration file routines:NCONF_get_string:no conf or environment variable:crypto\\conf\\conf_lib.c:272:\n```\n\n完整过程如下：\n\n\n```\nD:\\ssl>openssl genrsa -out server.key 4096\nGenerating RSA private key, 4096 bit long modulus\n..............................................................................................................................................................................................................++\n.................................................................................................++\ne is 65537 (0x010001)\n\nD:\\ssl>openssl req -new -key server.key -out server.csr\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:CN\nState or Province Name (full name) [Some-State]:SC\nLocality Name (eg, city) []:ChengDu\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (e.g. server FQDN or YOUR name) []:troyyang\nEmail Address []:yangzhoumemail@163.com\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:\nAn optional company name []:\n\nD:\\ssl>x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\n'x509' is not recognized as an internal or external command,\noperable program or batch file.\n\nD:\\ssl>openssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\nSignature ok\nsubject=C = CN, ST = SC, L = ChengDu, O = Internet Widgits Pty Ltd, CN = troyyang, emailAddress = yangzhoumemail@163.com\nGetting Private key\n\nD:\\ssl>\n```\n\n\n## nginx 搭建\n### 下载安装\n从官网下载nginx 最新稳定版Stable version (非常的小，只有不到2M，我的版本号是1.12.2)  http://nginx.org/en/download.html\n\n然后根据[官方文档](http://nginx.org/en/docs/windows.html)提示解压安装\n```\ncd c:\\\n// unzip nginx-1.12.2.zip (可以手动解压)\ncd nginx-1.12.2\nstart nginx\n```\n\n检测是否启动成功\n```\nC:\\nginx-1.12.2>tasklist /fi \"imagename eq nginx.exe\"\n\nImage Name           PID Session Name     Session#    Mem Usage\n=============== ======== ============== ========== ============\nnginx.exe            652 Console                 0      2 780 K\nnginx.exe           1332 Console                 0      3 112 K\n```\n有两个进程，说明启动成功，一个进程是nginx的主进程，另一个是工作进程。\n\n这里提一点\n> 解压完成后，最好是不要去直接点击nginx.exe文件安装，我就被坑过，解压完成后直接点击，当时什么也没发生，只有窗体闪烁了一下。等到cmd执行start nginx时，怎么都启动不起来。后来执行nginx -s reload后就对了。原因据说是双击运行程序会改变配置文件nginx.conf，所以需要reload。\n\n当nginx启动后，正常情况下，访问localhost应该可以的，会有nginx欢迎页面，如果没有，检查是不是IIS服务器没关，因为IIS会有可能把80端口占用\n\n### 配置SSL\n此时nginx只支持http，所以需要把刚才生成的自签名证书配置到nginx里，找到配置文件\"C:\\nginx-1.12.2\\conf\\nginx.conf\"，然后取消下面注释并配置路径\n```\nserver {\n        listen       443 ssl;\n        server_name  localhost;\n    \n        ssl_certificate      D:\\ssl\\server.crt;\n        ssl_certificate_key  D:\\ssl\\server.key;\n    \n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  5m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n    \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n    }\n```\n访问https://localhost就应该可以看到https安全提醒，选择继续就可以得到如下结果\n![image](https://images.troyyang.com/2017-11-7-nginx-ssl.PNG)\n\n## 反向代理Node 服务\n使用express创建个最简单node服务器，端口为3000\napp.js\n```\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => res.send('Hello World!'))\n\napp.listen(3000, () => console.log('Example app listening on port 3000!'))\n```\n运行服务并确保localhost:3000能访问到。\n```\nnode app.js\n```\n\n### Nginx 反向代理配置\n找到上述Nginx配置文件，将443的server location 改为下面部分：\n```\n    server {\n        listen       443 ssl;\n        server_name  localhost;\n    \n        ssl_certificate      D:\\ssl\\server.crt;\n        ssl_certificate_key  D:\\ssl\\server.key;\n    \n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  5m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n    \n        location / {\n\t\t\tproxy_pass http://localhost:3000;\n\t\t}\n    }\n```\n如果一切OK，访问https://localhost 会得到hello world的输出。至此，一个在windows平台上使用ssl + node + nginx的服务就搭建好了。\n\n参考：\nhttps://stackoverflow.com/questions/7360602/openssl-and-error-in-reading-openssl-conf-file\n\nhttps://blog.didierstevens.com/2015/03/30/howto-make-your-own-cert-with-openssl-on-windows/\n","tags":["node"],"categories":["笔记"]},{"title":"js 笔记之完美继承的演变","url":"/2017/10/21/Javascript_Prototype_Inherience/","content":"首先提个问题，都知道JS中的继承方式演变了很多种，你能完整的写出一种吗？用的最多的又是那种？如果你只能想到SubClass.prototype = new ParentClass()的同学就真该好好面壁了。\n\n前段时间写了一篇[JS继承的简单理解](https://troyyang.com/2017/06/25/Javascript_Prototype_Inherience_Understanding/)，实在是太简单了，主要是为了梳理原型和构造器的关系。最近在对公司新同事的培训中涉及到JS核心部分，所以又仔细去研究了一下，整理出这篇笔记，如有错误，欢迎指出并拍砖。\n\n## 什么是JS 中的继承？\n创建的子类将继承超类的**所有属性和方法**，包括构造函数及方法的实现。记住，所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。\n\n## 完美继承\n以前在开发中，使用继承用得最频繁的继承方式莫过于[MDN](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance)上所推荐的，据说也是最完美的继承，也就是下面这种：\n```\nfunction Person(first, last, age, gender, interests) {\n  this.name = {\n    first,\n    last\n  };\n  this.age = age;\n  this.gender = gender;\n  this.interests = interests;\n};\nPerson.prototype.greeting = function() {\n  alert('Hi! I\\'m ' + this.name.first + '.');\n};\n\nfunction Teacher(first, last, age, gender, interests, subject) {\n  Person.call(this, first, last, age, gender, interests);\n\n  this.subject = subject;\n}\nTeacher.prototype = Object.create(Person.prototype);\nTeacher.prototype.constructor = Teacher;\n```\n\n毫无疑问，这种继承方式是基于原型链的，而并非其他复制方式的继承，而最新ES6 class中的extends也其实就是上面的一种语法糖，所以搞清楚其中的原理至关重要。上面涉及到的东西对于新手而言挺多了，关于this的部分我希望自己再在整理单独一篇文章，而且其实以前使用的时候并没有真正理解所有的地方。以上核心的地方有三个。\n- Person.call \n- Teacher.prototype = Object.create(Person.prototype);\n- Teacher.prototype.constructor = Teacher;\n\n\n## 一步一步往上爬（继承的演变）\n现在忘记上面的最终成品，我们可以一步一步如抽丝剥茧般的达到上述结果。\n\n### 最简单的原型链继承\n```\n function A(a){\n    this.val = a;\n    this.arr = [];\n}\nfunction B(){\n}\nB.prototype = new A();\n\nvar b1 = new B();\nvar b2 = new B();\nb1.val = 1;\nb1.arr.push(1);\nconsole.log(b1.val) // 1\nconsole.log(b1.arr); // 2\nconsole.log(b2.val) // undefined\nconsole.log(b2.arr); // 2\n```\n这可能是很多人的第一个继承版本，可惜因为两个问题根本没法用。\n- 原型对象的引用属性是所有实例共享的 （b1对arr的改变影响到了b2的arr, val则没有影响，因为arr是引用类型）\n- 没法使用父类的构造器参数\n\n### 构造函数继承\n为了解决上述问题，于是改进代码：\n```\n function A(a){\n    this.val = a;\n    this.arr = [];\n    this.func1 = function(){}\n}\nfunction B(param1){\n    A.call(this, param1])\n}\nB.prototype = new A();\n\nvar b1 = new B(1);\nvar b2 = new B(2);\nconsole.log(b1.val) // 1\nconsole.log(b1.arr); // 1\nconsole.log(b2.val) // 2\nconsole.log(b2.arr); // 2\nconsole.log(b1.fun1 === b2.fun1) // false\n```\n好，原型对象属性和构造器参数问题虽然解决了，但是原型的方法并没有实现共享，所以会造成极大的内存浪费，所以也是不可取的。\n\n### 组合继承\n```\nfunction A(a){\n    // 只在此处声明基本属性和引用属性\n    this.val = a;\n    this.arr = [];\n}\n//  在此处声明函数\nA.prototype.func1 = function(){};\n\nfunction B(param1){\n    A.call(this, param1)\n}\nB.prototype = new A();\nvar b1 = new B(1);\nvar b2 = new B(2);\nconsole.log(b1.fun1 === b2.fun1) // true\n```\nA.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过B.prototype = new A();继承父类函数，实现函数复用。\n\n到了这里，似乎我们找到了最佳继承方式，可惜还是有一个小小的缺点：A构造器会被调用两次, 一次是new A的时候，还有一次是A.apply调用的时候。\n\n### 完美继承\n从组合继承我们可以看出，真正的问题在于new A()。我们在这一步的时候其实仅仅只是想要通用父类prototype中定义的方法（父类的属性我们已经通过apply的那一行调用到了），所以我们只需要改进这一步就好了。\n\n也许你会想，那直接使用A的prototype不就完了\n```\nB.prototype = A.prototype;\n```\n肯定是不行的，因为任何B对原型的修改都讲影响到A的原型，比如我们给B的原型增加一个方法。此外，原型上的构造器也会是同一个B.prototype.constructor === A.prototype.constructor。\n\n怎么办？一个聪明的方式是创建一个空对象然后把空对象的原型指向A的原型，因为这样的空对象是不占用任何内存的。\n```\nvar temp = new Object();\ntemp.__proto__ = A.prototype;\n\nB.prototype = temp;\n```\n\n而其实，上面的代码就是我从[Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)源码中拷贝过来的，所以我们可以改写为：\n```\nB.prototype = Object.create(A.prototype);\n```\n\n综上所述，我们的完美继承应该是这样的：\n```\nfunction A(a){\n    // 只在此处声明基本属性和引用属性\n    this.val = a;\n    this.arr = [];\n}\n//  在此处声明函数\nA.prototype.func1 = function(){};\n\nfunction B(param1){\n    A.call(this, param1)\n}\nB.prototype = Object.create(A.prototype);\n```\n\n然后，还是有个瑕疵（我保证是最后一个）：B.prototype.constructor === Object， 所以，我们这个时候需要重置B的原型构造器指向：\n```\nB.prototype.constructor = B;\n```\n\n好了，完美继承方式就是这样来的，我们在回过头去看看文章开头那段MDN给出的继承方式，是不是所有的都理解了：\n- Person.call \n目的是调用父类构造函数或者仅仅理解为借用构造函数中的代码为自己赋属性值，所以属性都定义在父类构造器中\n- Teacher.prototype = Object.create(Person.prototype);\n目的是父类原型中的函数复用，所以共享方法都定义在父类原型中。\n- Teacher.prototype.constructor = Teacher;\n目的是重置子类原型构造器，具体原因可以参考[why-is-it-necessary-to-set-the-prototype-constructor](https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor)\n\n\n参考：\n\nhttps://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nhttp://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp\nhttp://www.cnblogs.com/ayqy/p/4471638.html\n","tags":["web前端"],"categories":["笔记"]},{"title":"高可靠性MongoDB 安装指南","url":"/2017/09/01/mongo-installation-guide/","content":"\n最近项目中用到了MongoDB，顺便就写了安装说明文档，包括创建高可靠性的副本集replica-set，远程连接，密码登录等配置。\n### 安装 MongoDB\n\n1. 下载 [MongoDB](https://www.mongodb.com/download-center?jmp=nav#community)\n2. 系统环境设置. (Path: C:\\Program Files\\MongoDB\\Server\\3.4\\bin)\n\n### 创建 MongoDB 实例\n\n1. 创建高性能副本集replica-set数据库，打开命令行 (mongod代表着服务器)\n```\n>mkdir d:\\mongodb\\db01\n>mongod --port 27017 --dbpath \"d:\\mongodb\\db01\" --replSet \"rs01dev\"\n```\n运行成功后，副本集db01已经创建成功并处于运行中，此时不关闭命令窗体，保持其运行状态。\n\n2. 初始化 [replica-set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/).\n打开另一个命令窗体，并运行下面命令(mongo代表着客户端)\n```\n>mongo\n>rs.initiate({\n    _id: \"rs01dev\",\n      version: 1,\n      members: [\n         { _id: 0, host : \"127.0.0.1:27017\" }\n      ]\n})\n>rs.config()\n```\n上面的命令将会创建一个主副本集（节点）\n\n3. 创建数据库 'myDB'\n```\n>use myDB\n>db.createUser(\n  {\n    user: \"troyyang\",\n    pwd: \"5469a64fe0a336da365f44f5980f573c\",\n    roles: [\n       { role: \"readWrite\", db: \"myDB\" },\n       { role: \"dbAdmin\", db: \"myDB\" }\n    ]\n  }\n)\n// 上面的命令不会马上创建出数据库，只有插入语句会触发创建数据库\n>db.test.insert({\"name\":\"name1\"})\n```\n\n###  登录验证\n默认情况下，mongo数据库的连接是不需要验证的，这就是为什么上面的那个客户端能直接连接上服务端，所以这样是极其不安全的做法，因此我们这里需要使用登录验证的方式。\n\n关闭上面的客户端命令行，以及服务端。然后打开一个新的命令窗体并执行下面命令开启服务器：\n```\nmongod --auth --port 27017 --dbpath \"d:\\mongodb\\db01\" --replSet \"rs01dev\"\n```\n此时，需要验证的服务器开启完成，非常简单，可以看出，唯一的不同是多了一个 --auth的参数。\n\n###  客户端登录验证测试\n* 命令行客户端测试: 打开一个新的命令行窗体（本机或者外部机器），然后执行:\n```\n>mongo 127.0.0.1:27017 -u \"troyyang\" -p \"5469a64fe0a336da365f44f5980f573c\" --authenticationDatabase \"myDB\"\n```\n\n* Robomongo 测试\n略\n","tags":["No-SQL"],"categories":["数据库"]},{"title":"Hexo-lazyload-image图片懒加载","url":"/2017/08/06/hexo-lazyload-image/","content":"\n### 动机\n最近在看Google Chrome新出的一个API是无意间想到了对图片的懒加载，后来想想自己的网站还不支持呢，索性花了些时间让网站给支持上了，并发现Hexo上还没有一个懒加载的插件，又倒腾着写了个hexo的插件[hexo-lazyload-image](https://www.npmjs.com/package/hexo-lazyload-image)，并发布到NPM上供大家使用，从这几天下载数来看看来大家还是很有这个需求 :)。\n### 图片懒加载\n图片懒加载是提升网站性能和用户体验的一个非常很好方式，并且几乎所有的大型网站都使用到了，比如微博，仅把用户可见的部分显示图片，其余的都暂时不加载，做法就是：让所有图片元素src指向一个小的站位图片比如loading，并新增一个属性(如data-original)存放真实图片地址。每当页面加载（或者滚动条滚动），使用JS脚本将可视区域内的图片src替换回真实地址，并做请求重新加载。 \n### Hexo-lazy-image 实现原理\n因为文章都是使用markdown来编写的，所以不可能要求我们在markdown里将所有图片路径都指向站位图片，并附加另一个属性，所以，这个工作必须留给hexo的generate部分来做。\n\n最终可分为两步： \n1. 在hexo *after_post_render*事件或者*after_render:html*事件里将生产出来的文章html代码中所有img元素都加上 data-original 属性，并把src值付给他， 然后在将src值致为loading图片\n2. 注入simple-lazyload脚本在每个页面最后面，当页面加载过后负责判定当前需要重新加载的图片。\n\n这里重点提提正则表达式，在对第一步替换的时候，只是使用了简单的正则表达式去匹配查找所有的img节点，后来发现不仅如此，正则表达式结合string.replace更是如此强大，直接将我原来30行的代码减为3行，从此热爱上了正则表达式。\n```\nreturn htmlContent.replace(/<img(\\s*?)src=\"(.*?)\"(.*?)>/gi, function (str, p1, p2) {\n        return str.replace(p2, loadingImage + '\" data-original=\"' + p2);\n    });\n```\n\n关于simple-lazyload，这个是懒加载替换脚本的核心，原来使用jquery-lazyload插件，后来觉得没必要，最终还是自己写了个简单版。\n\n\n### Hexo-lazy-image 使用\n安装步骤：\n```\nnpm install hexo-lazyload-image --save\n```\n\n然后修改 _config.yml 文件\n```\nlazyload:\n  enable: true \n  onlypost: false\n  loadingImg: # eg. ./images/loading.png \n```\n\n既然要分享出来，那就得提供更多灵活的API来满足不同的需求，所以又加上了以下功能:\n\n1. 自定义占位图片。（不指定使用默认值）\n2. 只针对文章内容或者全网站图片使用图片懒加载\n\n\n### 关于npm 发布包那点事\n发布NPM包的时候有几个注意事项，这里列一下\n* 每次publish必须在readme中更新版本号(npm patch会自动为你生成最新版本号方便你使用)\n* 要更新npm中的readme页面，需要再次调用npm patch命令，不然尽管你已经更新了readme文件，npm包页面还是保持原来的页面\n* 在packages.json中最好把git地址加上，因为npm会自动解析packages.json文件，会映射到包页面相应的位置\n","tags":["web前端"],"categories":["web前端"]},{"title":"Javascript中原型链继承的简单理解","url":"/2017/06/25/Javascript_Prototype_Inherience_Understanding/","content":"以前对于Javascipt中的继承，大部分只是基于代码层面，理论理解虽然看了很多，总是当时理解了过几天确又忘了怎么的了。这两天又看了一遍《Javascrip面向对象编程指南》，其中在说到原型链的时候有一段话解释了很多以前自己容易混淆的地方：\n> 首先我们知道每个对象都会有一个构造器，而原型本身也是一个对象，这意味着它必然也有一个构造器，而这个构造器又会有自己的原型，于是这种结构就会持续下去，形成一个原型链。\n\n## 实践出真知\n理解这段话并不难，可如果没有在实践中去理解，就会像以前一样，老是记不住。\n### 实例对象的各种属性\n先看看最简单的内置对象string类型的各种构造函数（构造器）和原型，a一定是实例化的对象，而不是构造函数(构造函数一般是大写)。\n\n![image](https://images.troyyang.com/2017-6-25-js-inherence.png)\n\n从上面我们可以很直观的看到很多东西：\n- a是由String构造函数(constructor)创建的。\n- a的构造器函数(constructor)是有原型(prototype)的。\n- a是没有原型属性(prototype)的。\n- 神秘的__proto__直接是对a构造器的原型的引用。\n\n所以如果a里有我们继承的原型属性值rating，我们平时就可以这样使用:\n```\na.constructor === String\na.constructor.prototype.rating === a.rating\n```\n\n### 构造函数的原型\n\n在JS中实现继承的方式有很多，而我最喜欢这种[Mozilla](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)推荐的:\n```\nfunction User(auth) {\n    BaseManager.call(this, auth);\n}\nUser.prototype = Object.create(BaseManager.prototype); // IE8 不支持Object.create\nUser.prototype.constructor = User;\n```\n代码其实不难，也容易理解，首先是构造函数内调用基类，然后是原型覆盖，最后是构造函数重新赋值。其中最最最应该理解的是User是个构造函数而不是实例化的对象，只有构造函数是有prototype属性的，这和上面的实例化对象a是不一样的。\n","tags":["web前端"],"categories":["笔记"]},{"title":"Travis-ci自动编译部署github上的项目","url":"/2017/06/24/Travis_Auto_Build_Deploy_Github_Projects/","content":"在使用Hexo写完一篇博客后，都需要手动在本地编译，并生成静态文件，最后在上传至github服务器上才能发布，繁琐步骤姑且不说，万一哪天换了台电脑，没有Hexo环境的时候如何写博客呢又或者修改博客Bug？要是直接在github源码里写好文章后能自动编译发布就好了，好在github的好基友travis可以轻松帮我们同时实现这种持续集成, 持续部署。\n## 前因\n我的博客是基于[Hexo](https://hexo.io/)写的，最终发布地址是托管到Troy-Yang/troy-yang.github.io下的，为了方便，我把源码放在他的一个source分支下，以前要写一篇博客的做法是：\n1. 获取Source分支，使用markdown写好文章放在指定目录\n2. 安装搭建hexo环境\n3. 使用Node编译这个hexo项目\n4. 使用Node发布编译后的结果到github上\n\n缺点显而易见，我必须要搭建hexo的环境，并且还需要获取到source源码，而我只是想写一个markdown啊或者修改博客里某个css文件的bug，所以最理想的做法就是能自动检测到我的源码改动并自动编译部署，就和我们平时项目开发时的CI、CD一样。\n\n## [Travis](https://travis-ci.org/)\n不想介绍太多它，只想提一点的是它只针对开源项目免费，并且和github上的项目集成，所以所有github上的项目都可以使用它做CI、CD。\n> 这也就是为什么我们看到很多github上的项目都有.travis.yml文件\n和任何CI服务器一样，它的作用就在于可以捕捉任何代码提交并自动化的编译部署项目。\n\n## 第一步，github上添加access token\n登录github，进入到setting => develop setting => personal access tokens\n\n在description里输入任意token 名字，比如Travis-CI，并勾选上下面所有复选框。这个时候会生成token，请务必记住，因为他只会出现一次，否则需要重新生成(这个就是)。\n\n![image](https://images.troyyang.com/2017-6-24-github-create-token.png)\n\n\n## 第二步，添加github上的项目至travis上\n使用github账号登录[https://travis-ci.org/](https://travis-ci.org/)，这个时候你会看到自己所有github上的项目，选择需要做自动集成的项目troy-yang.github.io\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-create.png)\n\n## 第三步, 添加access token到travis上\n第一步和第三步的目的是保护你的access token除了travis和你自己以外别人都看不到，你肯定不希望把access token放在.travis.yml文件里让大家都看到吧。\n\n在travis上进入troy-yang.github.io 后，在右上角more options里找到setting，打开后，勾选 [Build only if .travis.yml is present] 并且 在Environment Variables中添加github上的access token。\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-setting.png)\n\n## 第四步,　添加编写.travis.yml\n在项目源码根目录(我的是troy-yang.github.io source分支), 添加.travis.yml文件，内容如下:\n```\nlanguage: node_js\nnode_js: stable\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n\nbefore_install:\n  - git submodule update --init --remote --recursive\n  \n#before_script:\n # - npm install -g gulp\n\nscript:\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"troyyang\"\n  - git config user.email \"yangzhouemail@163.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GitHub_TOKEN}@${GH_REF}\" master:master\n# E: Build LifeCycle\n\nbranches:\n  only:\n    - Source\nenv:\n global:\n   - GH_REF: github.com/Troy-Yang/troy-yang.github.io.git\n```\n\n里面最重要的可能就是执行脚本和变量，脚本。 其中hexo g是编译hexo 项目命令，after_script是编译命令完成后将结果推送至github项目下。${GitHub_TOKEN} 和 ${GH_REF}是两个占位符，第一个就是我们在Travis项目下添加的Token，会在travis执行的时候自动替换，第二个就是下面env的一个变量，这里我们也可以不要这个变量直接放地址也可以。还有一点的是branch指定，我们这里只需要Source 分支。\n\n根据不同项目，travis.yml文件内容各有不同, Travis上的一个官方demo文件[.travis.yml]( https://github.com/travis-ci/cat-party/blob/master/.travis.yml)\n\n## 第五步，测试\n让我们试试直接浏览器登录github，然后在troy-yang.github.io.git下的source分支下提交任何文件修改。在登录Travis，此时你可以看到一旦提交，Travis这边马上开始执行流程，看起来非常赏心悦目。\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-build.png)\n\n从此发布文件，修改博客bug是如此容易！博客如此，其他开源项目同样如此。\n","tags":["hexo"],"categories":["笔记"]},{"title":"踩过的坑--CORS跨域请求中预检(preflight)","url":"/2017/06/06/Express_Cors_Preflight_Request/","content":"***\n### 开头\n这两天在使用NodeJS Express搭建REST服务器时遇到一个很典型的AJAX跨域包含自定义请求头问题（用于身份验证），在花了大半天时间排查问题后发现自己对CORS真正的理解还很不够，尤其是pre-flight。\n\n### 需求描述\n服务端使用NodeJS Express搭建包含JWT身份验证的REST Full API， 客户端在获取到JWT信息之后的每次API请求头中都附带上JWT信息，完成身份验证后才能执行API操作，否则返回401错误。\n\n#### 代码\n\n服务器端(CORS核心部分):\n\n```\n------ App -----\n...\n// Enable CORS from client-side\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, OPTIONS\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials\");\n  res.header(\"Access-Control-Allow-Credentials\", \"true\");\n  next();\n});\n\n//parse application/json and look for raw text                                        \napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.text());\napp.use(bodyParser.json({ type: 'application/json' }));\n\n// Routes configuration\napiRoutes(app);\n\napp.listen(port);\n\n------- User -----\n//==========================\n// User Routes\n//==========================\napiRoutes.use('/user', passport.authenticate('jwt', {session: false }), userRoutes);\nuserRoutes.get('/', user.getUsers);\nuserRoutes.get('/:id', user.getUser);\nuserRoutes.post('/', user.postUser);\nuserRoutes.put('/:id', user.updateUser);\nuserRoutes.delete('/:id', user.deleteUser);\n```\n\n上面的代码看起来还是那么多清晰，在PostMan 测试中附带jwt也是没有任何的问题，成功返回。\n![image](https://images.troyyang.com/2017-06-05-CORS-Postman.PNG)\n\n接下来是客户端(jquery ajax):\n\n```\n------- Core --------\nfunction BaseManager(auth) {\n    this.baseApiUrl = 'http://localhost:8080/api/';\n    this.auth = auth;\n}\nBaseManager.prototype.get = function (url, successCallback, errorCallback) {\n    this.ajax(url, {}, 'get', successCallback, errorCallback);\n}\nBaseManager.prototype.ajax = function (url, data, type, successCallback, errorCallback) {\n    let that = this;\n    $.ajax({\n        url: url,\n        method: type,\n        data: data,\n        beforeSend: function (req) {\n            req.setRequestHeader('Authorization', that.auth.authorizationToken);\n        }\n    })\n        .done(successCallback)\n        .fail(errorCallback);\n}\n----------- User -------\nUser.prototype.getUserById = function (id, successCallback, errorCallback) {\n    let url = this.baseApiUrl + '/user/' + id;\n    this.get(url, successCallback, errorCallback);\n}\n```\n\n### 永远的401\n然后， 问题出现了，尽管参数是如何的对，Chrome console下总是返回让人咬牙切齿的大红色401，甚至断点都没有进入到passport的Jwt middleware下。\n![image](https://images.troyyang.com/2017-06-05-401-error.PNG)\n\n无数次的尝试，先是怀疑客户端ajax调用没对，甚至搬用最原生的ajax方法， 也怀疑过是服务端Jwt passport没写对，最后比较http请求头的时候发现了一些问题。\n\n使用Post man在node服务器端得到的request是这样的：\n\n![image](https://images.troyyang.com/2017-06-05-request-header-postman.PNG)\n\n通过浏览器ajax请求是这样的：\n![image](https://images.troyyang.com/2017-06-05-request-header-browser.PNG)\n\n有人给我把请求头信息更改了！Authorization不见了，甚至连req.method都变成了OPTIONS，而不是GET。\n\n### 罪魁祸首---预检(Pre-flight)\n百思不得其解，Google相关关键词后，pre-flight浮出水面，到了这步，突然想起阮一峰的《[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)》，当时只是略读，大概了解CORS中有两种请求：简单请求和非简单请求。于是又翻出来看了下，此时的情况正是属于非简单请求，会发送两次的请求，第一次就是preflight，用于请求验证, 第二次才是用户真正需要发送的请求。\n\n对于Pre-flight权威的解读： [mozilla.org](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests )\n\n回到代码中，不巧，每次服务端捕捉到的就是这个preflight请求，然后做next，其中就包括Jwt 中间件，而因为请求头中没有Authorization这个header，Jwt就返回了401，而这个过程是在passport的JWT中自动检测的，自己写的JWT验证部分甚至都没有执行到！\n\n### 解决办法\n看了[express cors](https://github.com/expressjs/cors/blob/master/lib/index.js)源码后，其实把请求类型OPTIONS做个简单的过滤就好啦！！！\n\n```\n// Enable CORS from client-side\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, OPTIONS\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials\");\n  res.header(\"Access-Control-Allow-Credentials\", \"true\");\n  if (req.method == \"OPTIONS\") {\n    res.send(200);\n  }\n  else {\n    next();\n  }\n});\n```\n\n### 结语\n又想了一下为什么之前的项目一直没有这个问题，其实是因为很多框架以及帮我们实现好了，比如说.NET中的WebAPI, 在做验证的时候我们都不用去考虑需要捕捉pre-flight请求，而在express中，甚至如果我当初直接使用三方库[express cors](https://github.com/expressjs/cors/blob/master/lib/index.js) 也可以避免，但是幸运的是，因为这种偶然，我们更有机会看得更清楚这些请求的后面到底是什么。\n\n看似简单的问题，却包括了很多需要自己去了解的东西，尤其是http各种请求头的含义，比如Content-type, Accept, 以及对应ajax应该传递的参数，最后，当然还有 Pre-flight!\n","tags":["jwt"],"categories":["笔记"]},{"title":"给Github自定义域名加上HTTPS","url":"/2017/05/21/Add_Free_Certification_In_Blog_Step_By_Step/","content":"***\n \n### 写在开头\n随着Https越来越成为一种趋势，最近也给自己家博客弄上了高大上的https，主要是结合使用的cloudflare和七牛云（图床）使用，关键是免费！所以想把这个过程记录下来，万一有人用得到呢。(还想抽空写写对Https的原理的理解，主要目的还是总结前段时间自己对Https的学习。)\n\n### Https时代\n>According to Mozilla since January 2017 more than half of the Web traffic is encrypted. [wiki pedia](https://en.wikipedia.org/wiki/HTTPS) \n\n维基百科告诉我们，自从2017年1月，超过一半的网络请求是通过加密过后的。百度也告诉站长们：\n> 为了给用户提供一个安全可靠的网络环境，继启用https加密之后，百度搜索再次重磅推出：全面支持https页面直接收录；另外从相关性的角度，百度搜索引擎认为权值相同的站点，采用https协议的页面更加安全，排名上会优先对待。[百度站长](http://zhanzhang.baidu.com/wiki/392)\n\nGoogle 今年更厉害，从1月份开始，所有没有用Https的网站会在Chrome浏览器地址栏前面加上不安全的图标：\n>Beginning in January 2017 (Chrome 56), we’ll mark HTTP pages that collect passwords or credit cards as non-secure, as part of a long-term plan to mark all HTTP sites as non-secure. [Google](https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html)\n\n百度2015年实现全站HTTPS，并且Google和百度都收录Https的网站并且提高其搜索排名，国外大型互联网网站基本都使用https，所以，有人说2017年是一个Https年。那既然如此，高大上的Https我们普通老百姓玩得起吗？要知道，一般的Https证书动辄也是几千块一年！\n\n### 天上掉下个证书\n没错，Cloudflare免费提供给证书，尽管你没有自己的服务器。Cloudflare是一个相当厉害的DNS服务商和CDN提供商，提供各种安全防范解决方案，全世界各地都有他的节点，对于国内，百度选择和他一起合作就是个很好的栗子，所以不用担心国内解析速度。所以我准备把主站的证书使用Cloudflare提供的。\n\n再一个就是七牛云，作为博客，不可能把文章图片全都放github上，所以最好还是要有自己的图床，但是好多图片床都是不支持https的，好在七牛可以免费申请证书。所以这是第二个证书。\n\n### 准备\n因为自己的博客站点暂时是托管到github上的，不是自己的服务器，所以并不能使用[Let's encrypt](https://letsencrypt.org/)在服务器端生成免费的证书，但好在一切都有cloudflare!\n\n- ~~有一个自己的域名~~（废话）\n- 自己的Github博客地址 (一般都是https://[username].github.io)\n- 注册Cloudflare\n- 注册七牛云 （如果有自己的图片床，并支持https, 可省去）\n\nCloudflare，主要用于域名解析，这是成功的关键！只有在他那里域名解析，他才能为我们提供多种证书服务。\n\n### 开始第一步: Github 自定义域名\n我们知道Github可以托管开源和私自项目(私有收费)，同样，功能强大的Github也可以提供静态页面站点，默认站点是 **https://[username].github.io** ，对应的站点代码是在reponsitory名为[username].github.io 下，如果没有，请创建自己的默认repository，可参考官方[说明](https://pages.github.com/)\n\n![image](https://images.troyyang.com/2017-5-21-https-github-home.png)\n创建成功后，我们就成功的创建了自己的个人站点: https://troyyang.github.io 显然这还不是我们的最终目的。\n\n接下来，打开这个repository, 定位到repo setting，绑定自己的域名，绑定完成后，我们可以看到repo代码下新加了一个CNAME的文件，换句话说，其实我们也可以直接在repo中直接添加这个文件即可，而不需要在setting中去手动设置，这个在我们静态站点发布的时候非常有用，因为每次发布后提交都会删除原有的文件，所以我们就可以在生成的文件中默认加上这个文件。\n\n![image](https://images.troyyang.com/2017-5-21-https-github-home-customdomain.png)\n\nCNAME\n```\ntroyyang.com\n```\n\n### 第二步：使用Cloudflare解析域名\n#### 修改默认DNS服务器\n在使用Cloudflare之前，我使用的是万网（现在是阿里云）的默认DNS服务器，也就是\n```\ndns9.hichina.com\ndns10.hichina.com\n```\n现在修改为Cloudflare\n```\napollo.ns.cloudflare.com\nmary.ns.cloudflare.com\n```\n个人觉得cloudflare作为DNS服务器特别快，修改了任何A记录或者其他记录会马上生效，不用再等待几个小时。\n#### 域名解析\n登录cloudflare, 将域名A记录指向Github服务器地址(同时也可指定CNAME记录去加上www)，绑定完成几分钟后访问troyyang.com或者www.troyyang.com 就可以访问到我们Github上那个默认的repo静态站点。这个时候可以尝试去访问https://troyyang.com 理论上是不会成功的，哈哈。\n![image](https://images.troyyang.com/2017-5-21-dns-cloudflare.png)\n\n### 第三步：使用Cloudflare的 Universal SSL 证书\n在Cloudflare管理页面，导航到Crypto，我们会看到SSL在Cloudflare上使用证书有三种方式: Flexible、Full、Full Strict，\n- Flexible SSL: 在访客与Cloudflare之间是加密的，从Cloudflare到自己服务器是不加密的，所以\n1. 你不需要在站点服务器上安装任何证书。\n2. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自Cloudflare）\n- Full SSL: 从访客到Cloudflare, 从Cloudflare到站点服务器都是加密的。Full 和 Full (Strict)不同之处在于Full Strict会去验证你服务器上的证书是否合法，而Full不会验证，所以你可以在你服务器上安装任何证书，包括自签名证书也是可以的。当然\n1. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自Cloudflare）\n- Full SSL (strict): 从访客到Cloudflare, 从Cloudflare到站点服务器都是加密的。你必须在你的服务器上安装有可信赖的CA证书，这个证书必须是未过期，包含有域名等信息的。同样\n1. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自自己申请的CA）\n\n三种模式如图\n![image](https://images.troyyang.com/2017-5-21-cloudflare-ssl.png)\n\n当然，我们选择Flexible，选择后我们还需要在下面的Edge Certificates栏目中新增Universal SSL 证书（当初以为选择Flexible后就等待24小时激活就完了，可几天过去了状态一直处于initilizing certification, 问了客服后，客服帮我加上这个Universal SSL证书就好了，给他们客服赞一个）\n\n在Edge Certificates中，点击Order SSL Certificate按钮，弹出几种证书，我们当然选择免费的那个, 然后填写证书服务的域名troyyang.com和*.troyyang.com.\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-universal-ssl.png)\n\n一步一步完成后就等待了，一般情况不会超过24小时就会生效，激活后就如下图（我个人选的是Full），然后就可以尽情的访问 https://troyyang.com\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-universal-ssl-success.png)\n\n如何你查看域名证书，细心的你除了看到Cloudflare签发的证书外，还有证书有效期只有半年，这个不用担心过期，客服小哥回复说他们会在快过期时自动延期的。\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-ssl-troyyang.png)\n\n### 七牛图床Https支持\nCloudflare客服小哥在帮我加好Universal SSL证书后，回复我说你网站还包括非https的内容也就导致所谓的mixed-content 问题，也就导致我当时在地址栏还看不到那个https图标，这个是我能想到的，因为我知道我的图片还都不是https，因为图片存放在七牛云上的，赶紧回去看看七牛是怎么支持https，于是在踩了无数坑过后终于让图片支持上了。\n\n#### 第一步： 在七牛上使用自定义域名 (images.troyyang.com)\n要使用https图床，必须得使用自定义域名（我使用的是images.troyyang.com），这个比较简单，可以参考[页面](https://developer.qiniu.com/fusion/manual/1367/custom-domain-name-binding-process)，我们可以先不选择https模式，让正常http先工作。主要工作就是在Cloudflare上新增一个CNAME记录指向七牛为自己域名生成的域名地址就好了。一切正常后，我们应该可以访问任意图片比如http://images.troyyang.com/2017-05-01-hexo-2015-wordpress.jpg\n\n要使用自定义域名，在七牛上，你必须等往账号里充至少10元，让自己成为标准用户，\n\n#### 第二步： 给自定义域名加上https支持\n现在要给自己的自定义图片域名加上https支持，在七牛上有两种方式，一种是上传自己已有的证书，第二种是申请免费证书或者购买证书。对于第一种，除了上传自己的证书公钥以外，还需要私钥也一同上传，所以我还是选择的第二种，反正也只是一个二级域名的证书，也并不存在任何私密性的东西。\n\n在七牛管理页面，在证书页面选择购买证书，然后选择TrustAsia的DV限免性，最关键的就是DNS的TXT验证了（[验证指南](https://developer.qiniu.com/fusion/manual/1703/qiniu-free-certificate)），我也是在使用了三次申请后才弄明白申请失败原因: Github上默认会解析出两个IP地址\n\n![image](https://images.troyyang.com/2017-5-21-qiniu-dig.png)\n\n解决方案就是，在Cloudflare上先删除所有A记录，CNAME记录，先添加上用作域名验证的Txt记录，等证书申请成功后（大约十几分钟），在恢复A记录，CNAME记录。这个是我Cloudflare上的相关解析最终样子\n![image](https://images.troyyang.com/2017-5-21-cloudflare-dns-all.png)\n\n有一点需要说明的是在七牛上如果只使用http的话，只要一个月不超过20G流量，是不会收费的，但是https是不在免费额度里面的。 \n\n\n\n","tags":["github"],"categories":["security"]},{"title":"《CSS设计指南》笔记","url":"/2017/04/20/Learn_Stylin_With_Css/","content":"## 选择器\n- 子元素 > :  用于选择所有给定子元素，如 .food>li\n- 后代元素： 用于选择所有子代和后代元素，如 .food li\n- 子-星 > *：用于选择所有直接子元素，而不包括后代元素. 注意：在为子元素设定垂直外边距时，只能使用 margin-top 和 margin-bottom，不能使用简写的 margin，否则会抵消用“子-星选择符”应用给这些元素 的水平外边距，如果你想进一步缩进某个子元素的内容，就应该给该子元素应用内边距如让子元素与栏边界保持一定距离\n```\narticle > * {margin:0 20px;}\n```\n- 非首位子元素 + : 这个选择符会选择除第一个之外的所有指定元 素，如\n```\n.list1 li + li {border-top:1px solid #f00;} \n```\n\n## 盒子模型\n- box-sizing:border-box 可用于避免改变内边距（边框）时导致整个盒子尺寸变化(width此时只是代表内容的宽度)，\n- .Inner 另一种解决盒子尺寸变化的方式就是在其内部再包一层盒子\n\n## 布局\n- 使用table-cell 布局(css3)\n```\nnav {display:table-cell; width:150px; padding:10px;      background:#dcd9c0;} \narticle {display:table-cell; padding:10px 20px;      background:#ffed53;} \naside {display:table-cell; width:210px; padding:10px;      background:#3f7ccf;} \n```\n\n## Display\n- 将行内元素改为块级元素实现文本选择范围扩大\n如，导航栏中文本\n```\n.list1 a {display:block; padding:3px 10px; textdecoration:           none; font:20px Exo, helvetica, arial, sansserif; \n```\n\n## font\n- 常用颜色\n![image](https://images.troyyang.com/2017-6-1-regular-colors.PNG)\n\n## background-clip\n借助[background-clip](https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip/)可以实现类似外边距分割效果，如\n```\n.multi-drop-menu ul {\n    float: left;\n}\n\n.multi-drop-menu li {\n    float: left;\n    list-style-type: none;\n}\n.multi-drop-menu a {\n    display: block;\n    color: #555;\n    background-color: #eee;\n    padding: .2em 1em;\n    border-width: 3px;\n    border-color: transparent;\n}\n.multi-drop-menu li a {\n    display: block;\n    border-right-style: solid;\n    background-clip: padding-box;\n    text-decoration: none;\n}\n\n<nav class=\"multi-drop-menu vertical\">\n\t<ul>\n        <li><a href=\"#\">Shirts</a></li>\n        <li><a href=\"#\">Pants</a></li>\n        <li><a href=\"#\">Dresses</a></li>\n        <li><a href=\"#\">Shoes</a></li>\n    </ul>\n</nav>\n```\n类似的用途如facebook的弹出框\n\n![image](https://www.w3cplus.com/sites/default/files/facebook-effects.jpg)\n> 使用background-clip把元素背景控制在padding或content区域内，这样一来，只需一个非常div，我们在这个div上加上透明边框，并配合background-clip把背景超过padding或content的边缘外的背景色直接裁剪掉著作权归作者所有。\n商业转载请联系作者获得授权,非商业转载请注明出处。\n原文: http://www.w3cplus.com/content/css3-background-clip © w3cplus.com\n","tags":["css"],"categories":["笔记"]},{"title":"小米路由器 安装 Shadowsocks 客户端","url":"/2017/04/16/XiaoMi_Router_Install_Shadowsocks/","content":"\n### 前因\n当然是为了省去多个终端连接的烦恼，而我的直接原因确是为了Google神器Chromecast能正常使用（就单单是电视投射功能就足以让我心动）。大半年前在美国买了一个Chromecast，在美国的时候工作的好好的，回国后确怎么也投射不了，总是找不到设备，大概猜到是因为被墙的原因，可惜电脑挂起了VPN还是不行，后来才知道是电视也需要连接Google 服务！坑爹啊！然后就一直静静的放着放着直到这次买了个服务器(也是为了科学上网)后，想试试让路由器直接连Shadowsocks。\n### 准备\n- 一台运行着Shadowsocks，并且能访问外网的服务器\n- 一台小米MINI路由器（其他的也行）\n- 一台装载了linux远程连接客户端的电脑(XShell或者Putty)\n\n### 第一步：开启路由器SSH\n我的是小米MINI路由器，因为默认是稳定版而不是开发版，所以第一步就是升级（也可能是降级）到开发版去开启SSH，具体步骤在[这里](http://jingyan.baidu.com/article/624e7459ae65e834e8ba5afd.html)或者 [这里](http://bbs.xiaomi.cn/t-10044297)\n> 升级前可以先备份路由信息\n\n### 第二步：连接到路由器\n升级完成后，使用在小米官网给出当前小米账号的root账号密码便可以登录路由器系统XIAO QIANG, 实质也是linux系统的一个distribution，查询后得知事实上生活中很多小的硬件设备都是搭载的linux系统，因为其开销实在太小啦\n![image]https://images.troyyang.com/2017-04-15-LoginXiaoMiRouter.PNG)\n\n查询当前路由器系统信息\n\n```\nuname -a\n/// Linux XiaoQiang 2.6.36 #1 MiWiFi-R1CM-2.15.75 Thu Apr 13 17:10:07 CST 2017 mips GNU/Li\n```\n\n### 第三部：安装Shadowsocks\n原本以为这个shadowsocks客户端其实就是github上的那个Linux Shadowsocks, 然后似乎并不是，只能猜测针对当前路由器又做过一次包装, 然后就发现了这么一个宝藏一键安装脚本：[http://d.ukoi.net/Miwifi/](http://d.ukoi.net/Miwifi/) \n\n也不知道作者是谁，只能猜测是对小米路由器系统很了解的人，所以根据这些安装脚本，我们就可以一步一步走向世界！之前试过很多小米论坛上的脚本，可惜基本都是不能下载的，所以很感激这位作者。\n\n运行下面的脚本:\n> 可以根据不同的小米路由器版本选择不同的脚本，更改相应的部分\n\n```\n// userdisk目录下的文件不会被系统reset\ncd /userdisk\n// 下载\nwget http://d.ukoi.net/Miwifi/MINI/mini_install.sh\n// 对文件赋权限\nchmod +x mini_install.sh\n// 安装\nsh mini_install.sh\n```\n\n之后就是按照输入要求输入客户端连接的一些参数，完成后不出意外基本没问题啦，家里面所有wifi覆盖的地方都能愉快的科学上网，当然最重要的就是我的电视也能投射啦。。。。\n\n还有一点就是这个脚本使用的是IP分流的，也就是说只有在GFW列表里的网站才会使用VPS，所以可以放心使用。\n\n参考\n\nhttp://www.miui.com/forum.php?mod=viewthread&tid=4133822&extra=\n\n\n\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"Ubuntu 安装 Shadowsocks 实现科学上网","url":"/2017/03/26/Ubuntu_Install_ShadowSocks/","content":"\n***\n\n### 开头\n看了shadowsocks的各种安装部署教程，因为对于linux不熟，所以遇到很多坑，自己留个笔记在这里\n### 更新\n使用Ubuntu 14.04 版本已经不是必须的，当时主要是因为在最新版本Ubuntu内核没在锐速支持列表中，现在发现一种新的拥塞加速算法BBR（Google开发的），而且默认在最新的Ubuntu内核4.11已经集成进去，所以只需要开启即可，再也不用考虑已经不提供官方服务的锐速。完成安装ShadowSocks 后，参见秋水逸冰的《[一键安装最新内核并开启 BBR 脚本](https://teddysun.com/489.html)》。\n### 环境准备\nOS: \n- Ubuntu 14.04 X64 LTS\n- Kernel Linux 3.13.0-112-generic\n\n> 似乎 从16.04 开始以上已经全面使用[systemd](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)来启动管理守护进程，而不是像传统在init.d来启动。\n\n\nVPS 平台: Vultr\n远程控制客户端: XShell 或者 Putty\n\n### 远程连接 ubuntu\n略\n### Shadowsocks 安装\n\n安装pytyon 的pip管理程序，因为shadowsocks是由python写的\n```\n$ apt-get install python-pip\n```\n\n安装shadowsocks程序 (方式一)\n\n```\n$ sudo pip install shadowsocks\n```\n安装shadowsocks程序 (方式二), pip 上的不是最新版本)\n\n```\n# 安装yum\n# 安装Python setuptools\n$ sudo apt-get install python-setuptools\n# 从github上安装shadowsocks\n$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master\n```\n\n\n查看是否安装成功\n\n```\n$ ssserver\n$ whereis ssserver\n```\n\n创建服务器配置文件(多端口)\n\n```\n$ vi  /etc/shadowsocks.json\n```\n\n\nvim 的命令: 按 \"i\" 进入编辑模式，编辑后按 \"esc\" 退出编辑模式， 输入 \":wq\" 保存退出vi\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\": {\n         \"443\": \"password1\",\n         \"8888\": \"password2\"\n     },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n启动服务，后台运行\n\n```\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n此时可配置好客户端shadowsocks检测是否可以访问\n\n### 设置开机启动(针对16.10以下版本)\n\n```\n$ vim /etc/rc.local\n```\n在exit 0以前插入开机执行命令\n\n```\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n### ShadowSocks 操作命令\n查看日志\n\n```\n$ sudo less /var/log/shadowsocks.log\n```\n\n### 防火墙端口开放\n```\nsudo iptables -I INPUT -p tcp --dport 8888 -j ACCEPT\n```\n为防止reboot后iptable重置，需要下面命令\n```\nsudo apt-get install iptables-persistent\n\nsudo /etc/init.d/iptables-persistent save \nsudo /etc/init.d/iptables-persistent reload\n##或者\nsudo netfilter-persistent save\nsudo netfilter-persistent reload\n```\n\n### BBR 加速\n一定要使用加速，使用和不使用的差别是：没使用时查看youtube 720P 看不了，速度只有区区6、70KB的速度，使用后瞬间7、800甚至1m，发挥出了带宽的最大威力！\nhttps://www.linuxbabe.com/ubuntu/enable-google-tcp-bbr-ubuntu\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"从wordpress主题中看CSS设计","url":"/2017/03/11/Learn_CSS_from_wordpress_theme/","content":"\n***\n\n### 写在开头\n最近想做个个人博客，看上了wordpress的[twentyfifteen](https://wordpress.org/themes/twentyfifteen/)模板页(2015默认模板)，看上了就想拥有，而拥有是需要付出代价的，于是就掉入了源码坑里，爬了一周才算勉强爬出来，回过头来觉得这个坑里还是有很多有营养的东西，毕竟是大公司，所有标准都是最新的，所以想总结下学到的东西，方便以后使用(持续更新中)\n\n***\n##  Responsive page (干货都写在最前面)\n在移动互联网时代，responsive的页面是必须的，我们知道css3里的media 可以帮我们实现不同设备尺寸的不同显示方式，所以设备尺寸的一个界定值就是我们的一个首要考虑问题，其他不多说，看看人家是如何定义的：\n\n```\n/**\n * 16.1 Mobile Large 620px\n */\n @media screen and (min-width: 38.75rem) {\n}\n/**\n * 16.2 Tablet Small 740px\n */\n\n@media screen and (min-width: 46.25rem){\n}\n\n/**\n * 16.3 Tablet Large 880px\n */\n @media screen and (min-width: 55rem){}\n\n/**\n * 16.4 Desktop Small 955px\n */\n \n@media screen and (min-width: 59.6875rem){\n}\n/**\n * 16.5 Desktop Medium 1100px\n */\n \n@media screen and (min-width: 68.75rem){\n}\n/**\n * 16.6 Desktop Large 1240px\n */\n@media screen and (min-width: 77.5rem){\n}\n```\n其中在mock的过程中发现几个tips\n* 上面只有min-width，没有设置max-width，这是一个灵活的设计，没有max-width就说明他可以从最小满足条件的media开始，只要满足条件，都会被执行到，而我们需要做的就是把共有的部分写在最小尺寸里，或者放最外面，然后在需要更改的部分属性在在需要的尺寸中更改。简单举个栗子：\n有个导航栏，需要在移动设备的时候隐藏，在桌面浏览器中显示所有，那我们可以这样:\n![](https://images.troyyang.com/2017-03-03-css-media-query.jpg)\n\n***\n\n##  如何在css文件中使用fontawesome图标字体库\n我们知道的是要在页面中使用fontawesome的图标很简单，只需要在html代码中加入如下代码\n```\n<i class=\"fa fa-address-book-o\" aria-hidden=\"true\"></i><a href=\"#\">列表</a>\n```\n其中fa代表的是默认图标大小，如果想改变图标的大小，可以使用集成的fa-lg(放大33%),fa-2x, fa-3x, fa-4x, fa-5x。所以用起来很爽是吧。\n\n从wordpress中(其实他没有用fontawesome图标库，而是他们自己的genericons库)，我看到了他是在css中定义这些图标的，试想一下，如果每次使用图标都需要新添加一个元素是不是很累赘，而且重复呢，这不符合程序设计的可复用原则啊！所以很自然的就想到使用class,这样就可以很轻松的在一些元素之前借助于伪类:before加上content神器自动加入，而我需要做的仅仅是在a标签加上一个class名称。\n\n其中很重要的一步是引入这个新font-family FontAwesome。\n实现如下：\n\n```\n[class*=\"font-asesome-icon\"]:before {\n  font-family: FontAwesome;\n  font-weight: normal;\n  font-style: normal;\n  display: inline-block;\n}\n\n.secondary-toggle:before {\n    color: #333;\n\tfont-size: 2rem;\n    content: \"\\f0c9\";\n    line-height: 40px;\n    width: 40px;\n}\n\n<a class=\"font-asesome-icon secondary-toggle\" href=\"#\">列表</a>\n```\n其中content代表的是该图标的Unicode, 每个fontawesome图标库里都能查到其对应的unicode。\n上面的是问题一，还有个问题是，我如何改变图标的大小呢？哈哈，我们回想一下这是什么库？对，字体库，所以，既然是字体，改变大小不就是font-size！我们上面是font-size:2rem，也就等于2*16px（rem是什么鬼一会再说），其实仔细查看fontawesome[官网](http://fontawesome.io/examples/)，然后任选一个图标，点击view css，我们会看到他的实现源码如下:\n\n```\n.@{fa-css-prefix}-lg {\n  font-size: (4em / 3);\n  line-height: (3em / 4);\n  vertical-align: -15%;\n}\n.@{fa-css-prefix}-2x { font-size: 2em; }\n.@{fa-css-prefix}-3x { font-size: 3em; }\n.@{fa-css-prefix}-4x { font-size: 4em; }\n.@{fa-css-prefix}-5x { font-size: 5em; }\n```\n\n## px, em, rem\n\n### 基本概念\n**px (pixel，像素)**：是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果px要换算成物理长度，需要指定精度DPI(Dots Per Inch，每英寸像素数)，在扫描打印时一般都有DPI可选。Windows系统默认是96dpi，Apple系统默认是72dpi\n\n**em** (相对长度单位，相对于当前对象内文本的字体尺寸)：是一个相对长度单位，最初是指字母M的宽度，故名em。现指的是字符宽度的倍数，用法类似百分比，如：0.8em, 1.2em,2em等。通常1em=16px\n\n**rem**（root em，根em）(相对长度单位，相对于根节点```html```的字体尺寸)\n\n\n在wordpress博客中看到使用了```rem```，之前只知道```em```，查看了[相关资料](https://webdesign.tutsplus.com/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984)后，学习到了:\n\n- rem 和 em 都是根据你设计的fontsize值最终被浏览器解释成pixel的\n- em 的值是根据当前他坐在的元素fontsize决定的\n- rem的值是由html根节点的fontsize决定的\n- em的值会被父元素的fontsize继承在计算(除非使用pixel显示的设置了当前元素的固定fontsize大小)\n- rem的值会被在浏览器设置中设置的fontsize大小影响(除非在html根节点下使用了pixel去固定fontsize大小)\n- 有时为了换算方便，经常为body设置fontsize 为65%\n\n### 如何选择 \n- 使用rem: 在文本大小值的设置上使用\n- 使用rem或者px: 在media queies中使用\n- 在和文本布局相关中，可使用em，比如某些文本的padding, margin 布局。防止因文本大小变化导致布局变得混乱\n- 在多列布局中，不要使用em或者rem来作为宽度，而使用 ```%```代替\n\n","tags":["css"],"categories":["web前端"]}]