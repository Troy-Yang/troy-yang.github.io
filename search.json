[{"title":"Mobx在项目中的实践 及 与Redux的比较","url":"/2020/12/20/mobx/","content":"\n之前在公司FEE内部做过一次技术分享，主要关于Mobx在项目中的使用一年后的体验以及和Redux 的一些比较（因为我们项目之前的状态管理选型选择的是mobx，而其他项目组的同学选择主要是Redux或者还在纠结如何选）。\n\n以下都是根据查询各种资料后的个人理解概览\n\n## Mobx Overview\n> Mobx looks like a properties tracking and reaction lib.   \n> 基础部分就省了，只说结论：Mobx 看起来是属性追踪及作出相应反应的库，和Redux 不一样的是，他的状态是mutable的。\n### Mobx 4 & 5\n* Mobx 4 Limitations (Observable)\n* Mobx 5 Proxy based (Only ES 6 Browser, no polyfill)\n\n## Mobx & Third-Party view lib\n* mobx & mobx-react\n* redux & react-redux\n* mobx & mobx-arch & mobx-backbone 有吗???\n\nMobx 是可以单独使用的，这点和Redux一样，可以不需要依赖于任何UI 库像，React, Vue，当然如果把他们结合到一起，那才能发挥出最大的作用，所以就理所应当的有mobx-react。\n\n我们公司内部有个UI 库叫arch，很老的了，requirejs时代的，比react, vue, angular还早，没有响应式的更新，核心只有一个render 方法，所以其实可以通过Mobx 简单改造为响应式的，一旦外部属性发生变化，就会触发重新渲染，至于内部状态嘛，呵呵，不考虑了，反正这只是个例子。\n```\nvar { observable, autorun } = require(\"mobx\");\nvar Entity = require('xx/xxxx/entity');\n\nvar todoStore = observable({\n  todos: [],\n  get completedCount() {\n    return this.todos.filter(todo => todo.completed).length\n  }\n})\n\nautorun(function () {\n  // For Backbone\n  this.xxxBackBoneComponent = new Entity({\n    model: todoStore.todos,\n    editable: true\n  });\n\n  // For Arch\n  active.render($html, () => {\n    this.xxArchComponent = arch.getComponent(xxx);\n  });\n})\n\ntodoStore.todos[0] = {\n  title: \"Take a walk\",\n  completed: false\n}\n```\n\n## Mobx Store Design\n* [Offical guide on Store design](https://mobx.js.org/defining-data-stores.html)\n* [Best Practice](https://medium.com/dailyjs/mobx-react-best-practices-17e01cec4140)\n* UI State & Domain State\n\n这是我觉得最难的部分，如何设计好Mobx的Store？官方给出的一个[guide](https://mobx.js.org/defining-data-stores.html) 是划分为Domain store 和 UI store。Domain store和Redux的one-single store 可不一样，这里是可以有多个的，像users, books, movies, orders 都可以是一个Domain Store， 至于UI store，暂时我们只是存储一些全局的属性。所以，我们的项目中Store的结构大致如下:\n```\nstores\n--root.ts\n--domain\n----aaaStore.ts\n----bbbStore.ts\n--ui\n----application.ts\n```\n\nroot.ts初始化所有domain和ui store:\n```\nexport default class RootStore {\n  @observable\n  aaStore;\n\n  @observable\n  bbStore;\n\n  @observable\n  applicationUIStore;\n\n  constructor() {\n    // Domain Store Init\n    this.aaStore = new AStore(this);\n    this.bbStore = new BStore(this);\n    ...\n\n    // UI Store Init\n    this.applicationUIStore = new ApplicationUIStore(this);\n    ...\n  }\n}\n```\n\n但是在实际的问题中，我们发现大部分的状态其实都是本地UI状态，（也许有人说用setState啊，如果业务复杂，状态很多, 并且基本会依赖其他store，最好抽出来）所以，问题来了，这些ui store我们放在哪里呢？同时，我们需要把Container 组件里的状态隔离开来，为什么隔离，一是因为UT 不好写（因为有inject，所以在UT里需要写很多Provider），二是傻瓜组件更不容易出错，参考Redux的connect用法，我们得到下面的结构：\n```\nContainerAComponent\n--ContainerAComponent.tsx\n--ContainerAComponentUIStore.ts\n```\nContainerAComponentUIStore.ts\n```\nexport default class ContainerAComponentUIStore {\n  rootStore;\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n  }\n\n  @observable\n  addHoc = '';\n  \n  @action.bound\n  onAdhocChange = (addHocNewValue) => {\n    ....\n  }\n```\nContainerAComponent.tsx\n```\nexport class ContainerAComponent extends React.Component {\n  handleAdhocChange = (e) => {\n    this.props.onAdhocChange(e.target.value);\n  }\n  ...\n}\nexport default connectComponentStore(ContainerAComponent, ContainerAComponentUIStore);\n```\n这样，我们导出了两个组件，一个是ContainerAComponent，就是一个简单组件，我们可以通过传统传props的方式去测试组件核心内容，另一个是HOC组件，其实是不用测试的。\n\n而至于connectComponentStore方法，就是一个很简单的HOC\n```\nexport default (WrapperedComponent, ComponentStore) => {\n  @inject('appStore')\n  @observer\n  class Connect extends React.Component {\n    @observable componentStore;\n\n    constructor(props) {\n      super(props);\n      this.componentStore = new ComponentStore(props.appStore);\n      this.ref = createRef();\n    }\n\n    static displayName = `${WrapperedComponent.displayName || WrapperedComponent.name}-withUIStore`\n\n    componentDidMount() {\n      this.componentStore.mapState(this.props);\n    }\n\n    componentDidUpdate(preProps, preState) {\n      this.componentStore.mapState(this.props);\n    }\n\n    render() {\n      return (<WrapperedComponent ref={this.ref} {...this.componentStore.toProps} {...this.props} />);\n    }\n  }\n\n  return Connect;\n};\n```\n\n我们业务里，绝大部分都是用到的这种本地UI Store + 简单组件组合这种方式，也许就是所谓的local state component （忘了哪里听到的了）\n\n### Mobx-State-Tree（MST）\n也许MST在大型项目中使用是个很好的方式，但我们暂时还没有去尝试。\n\n### Project Structure\n下面是Mobx的一些项目组织结构参考资料：\n\nhttps://medium.com/@daniel.bischoff/how-to-structure-your-mobx-react-app-8fd6d9d821a4     \nhttps://github.com/gothinkster/react-mobx-realworld-example-app   \n\n\n## Mobx-React vs Redux-React\n个人简单的一些看法：\n* Workflow\n* Freestyle vs Strict\n* OOP styles vs FP\n* Small vs Large\n* Time-traval problem (Resolved by MST)\n* Container components (Inject vs Connect)\n* [redux-crud-example](https://github.com/sitepoint-editors/redux-crud-example/tree/master/src) & [mobx-crud-example](https://github.com/sitepoint-editors/mobx-crud-example/tree/master/src)\n\nhttps://medium.com/@cameronfletcher92/mobdux-combining-the-good-parts-of-mobx-and-redux-61bac90ee448   \nhttps://www.sitepoint.com/redux-vs-mobx-which-is-best/\n\n### Learning Redux\n在一些小项目中用过Redux, 不得不说，Redux的学习成本要比Mobx高得多，比如下面的点，\nredux, reducer, action, container component, selectors(reselect), redux-thunk, normalizing, ducks, and more waiting...\n\n## Others links\n### [Mobx-Best-Practice](https://medium.com/dailyjs/mobx-react-best-practices-17e01cec4140)\n### Decorator (ES7/TS) vs no-decorators\n\n## End\n如果你有更好Mobx使用的一些心得，欢迎交流！\n","tags":["react"],"categories":["web"]},{"title":"纯JS实现按多列排序","url":"/2020/05/03/multi-sort-implement-with-native-js/","content":"\n### 重要的事情还是要说的\n项目里没引用 **lodash** （因为和 underscore.js 冲突）\n\n### 问题\n数据结构类似这种：\n```\nconst testData = [\n  { name: '1', primary: true, startDate: '2018-01-01T08:00:00Z', endDate: '2018-05-01T08:00:00Z' },\n  { name: 'A', primary: true, startDate: '2018-02-01T08:00:00Z', endDate: '2018-06-01T08:00:00Z' },\n  { name: 'a', primary: true, startDate: '2019-02-01T08:00:00Z', endDate: '2019-05-01T08:00:00Z' },\n  { name: 'b', primary: false, startDate: '2019-02-01T08:00:00Z', endDate: '2019-02-01T08:00:00Z' },\n]\n```\n最近项目中有大量的对排序的新需求，由其是按多列来排序， 新需求大致如下：\n\n- Archived 为true的排列到最后，否则排最前面\n- 然后，按照 StartDate 时间，如果最新，则排前面\n- 然后，如果 StartDate 相同，则按照 EndDate 来排，\n- 然后，如果 EndDate 也相同，则按照 name 的字母表的顺序排\n\n\n同时呢，之前项目中也有很多类似的需求：\n\n- 先按照 ModifiedDate 排，\n- 如果相同，则按 name 字母表顺序\n\n或者\n- Primary 为true 的排前面\n- 如果Primary 相同， 按照 name 字母表排序\n\n还有更多的类似需求，我们项目里原来有个 Sort.js 的公共方法来处理这些排序，选取了其中最长的一个 (其实上面需求的每一个实现都和这个差不多)\n```\nconst sortFlattenPrograms = (flattenPrograms) =>\n    flattenPrograms.sort((a, b) => {\n      // first sort by archived: unarchived first\n      if(a.archived && !b.archived) {\n        return 1;\n      } else if(!a.archived && b.archived) {\n        return -1;\n      }\n\n      // sort by start date: latest first\n      let dateCompareResult = compareDateLatestFirst(a.startDate, b.startDate);\n      if(dateCompareResult !== 0) {\n        return dateCompareResult;\n      }\n\n      // sort by end date: latest first\n      dateCompareResult = compareDateLatestFirst(a.endDate, b.endDate);\n      if(dateCompareResult !== 0) {\n        return dateCompareResult;\n      }\n\n      // sort by program name - location name: alphabetically (ignore case)\n      const nameCompareResult = compareStringAlphabeticallyIgnoreCase(getProgramFullName(a), getProgramFullName(b));\n      if(nameCompareResult !== 0) {\n        return nameCompareResult;\n      }\n\n      return 0;\n    });\n```\n\n是不是很长，很丑，而且这只是一个排序，还有很多这种和0比较，然后再比较，所以继续加下去肯定不可取，维护是个很大的问题，UT 也很难写，要是能抽出中间部分就好了？？？\n\n### 解决办法\n先贴代码，其实核心就是抽取上面的各种comparator， 并且采用链式的方式执行，这里使用reduce方法来取了个巧，其实，查看了lodash的实现后， 他们采用的是 while 实现。\n\n注意排序的顺序，是按照从右到左，我想的是尽量和 **functional programming** 的方式来写，并且compose 方法在lodash 里也是这个顺序，如果想改为从左往右，只需要将 **reduce** 改为 **reduceRight** 即可\n```\n/**\n   * Sort by order list from right to left\n   * For example: we want to order by start date, if date equal, then order by end date, if equal, then name\n   * composeOrderBy([oderByName, orderByEndDate, orderByStartDate])\n   * @param {*} comparators\n   */\n  const composeOrderBy = (comparators) => {\n    const makeChainedComparator = (first, next) => {\n      return function (a, b) {\n        var result = first(a, b);\n        if(result !== 0) return result;\n        return next(a, b);\n      };\n    };\n    return comparators.reduce(function (chained, first) {\n      return makeChainedComparator(first, chained);\n    });\n  };\n```\n\n所以，上面的需求可以简单改为下面，其实comparators 是一个我预先定义好的各种比较方法\n```\n// 预先定义的方法\ncomparators = {\n  compareStringField: (field, ignoreCase = true)=> (a, b) => { ... },\n  compareBoolField: (field, trueFirst = true) => (a, b) => { ... },\n  compareDateLatestFirst: (field) => (a, b) => { ... },\n}\n\ndata.sort(composeOrderBy([\n        comparators.compareNameIgnoreCase(),\n        comparators.compareDateLatestFirst('endDate'),\n        comparators.compareDateLatestFirst('startDate'),\n        comparators.compareBoolField('archived', false)\n      ]));\n\ndata.sort(composeOrderBy([\n        comparators.compareNameIgnoreCase(),\n        comparators.compareDateLatestFirst('modifiedDate')\n      ]));\n```\n\n最终还是需要用到 array的sort 方法，但由于这不是纯函数，所以保险的做法就是调用sort前，先在clone一下","tags":["js"],"categories":["Web"]},{"title":"神奇的 ES6 继承执行顺序问题","url":"/2019/12/17/神奇的-es6-继承执行顺序问题/","content":"刷推的时候无意间发现一位google 工程师发的一个感叹，感叹发现的一个神奇的JS 6继承顺序问题。。。\n\n![](/images/uploads/2019-12-17-js6-class-order-miracle-tweeter.jpeg)\n\n![](/images/uploads/2019-12-17-js6-class-order-miracle.png)\n\n\n\n仔细看了看，确实好神奇，于是好奇的看了看babel转换出的结果：\n\n```\nvar SuperClass = function SuperClass() {\n  _classCallCheck(this, SuperClass);\n\n  _defineProperty(this, \"foo\", function () {\n    return console.log('foo init in supper class');\n  }());\n\n  console.log('super construtor');\n};\n\nvar WhatEver =\n/*#__PURE__*/\nfunction (_SuperClass) {\n  _inherits(WhatEver, _SuperClass);\n\n  function WhatEver() {\n    var _this;\n\n    _classCallCheck(this, WhatEver);\n\n    console.log('before sub class constructor');\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WhatEver).call(this));\n\n    _defineProperty(_assertThisInitialized(_this), \"foo\", function () {\n      return console.log('foo init in sub class');\n    }());\n\n    console.log('after sub class constructor');\n    return _this;\n  }\n\n  return WhatEver;\n}(SuperClass);\n\nnew WhatEver();\n```\n\n就和他猜测的一样：没有supper的时候，字段的初始化是早于构造函数执行的，有supper的时候，字段初始化是在构造函数里的super后执行！\n\n个人看法是故意放super之后是为了能在字段里访问到父类的字段？\n","tags":["js"],"categories":["web"]},{"title":"使用NetlifyCMS在线编辑Github上的博客","url":"/2019/11/24/githug-netlify/","content":"### Netlify CMS 介绍\n\n使用Netlify CMS我感觉有以下优点：\n\n* 无缝支持Hexo 等十几种主流静态网站生成器 的 **文章后台管理***   \n* 可视化在线编辑、新增github 上的markdown\n* 自带图片上传功能\n* 自动部署\n\n支持列表：\nJekyll, GitBook,Hugo, Gatsby, Nuxt, Next, Gridsome, Zola,Hexo, Middleman, Jigsaw,Spike ,Wyam,Pelican,VuePress,Elmstatic,11ty,preact-cli\n\n![](/images/uploads/2019-11-24-netlifycms-list.png)\n\n### 为什么使用它\n\n对于我的情况：使用Hexo 网站生成器，托管在github上 <https://github.com/Troy-Yang/troy-yang.github.io>，其中Source branch是存放markdown等生成前分支，Master branch存放的是生成后的静态文件分支。\n对于以前，如果要写一篇文章，基本是在source 分支里，新增一个markdown文件（可github上在线添加或者本地新增然后push），然后自动触发github 上配置的travis 自动部署流程，整体感觉已经很不错了。现在配置上Netlify CMS后， 可视化的在线编辑以及图片管理更加方便，可以随时随地发文章。\n可惜, Netlify有个致命缺点：**需要翻墙访问**\n\n### HEXO  NetlifyCMS 配置\n\n只需要在hexo 的source/ 目录下添加admin 目录，新增下面两个文件：\n\n```\nconfig.yml\nindex.html\n```\n\nconfig.yml需要根据自己情况进行配置：\n\n```\nbackend:\n  name: git-gateway\n  branch: Source\n\n# This line should *not* be indented\nmedia_folder: \"source/images/uploads\" # Media files will be stored in the repo under images/uploads\npublic_folder: \"/images/uploads\" # The src attribute for uploaded media will begin with /images/uploads\n\ncollections:\n  - name: \"blog\" # Used in routes, e.g., /admin/collections/blog\n    label: \"Post\" # Used in the UI\n    folder: \"source/_posts\" # The path to the folder where the documents are stored\n    create: true # Allow users to create new documents in this collection\n    slug: \"{{slug}}\" # Filename template, e.g., YYYY-MM-DD-title.md\n    fields: # The fields for each document, usually in front matter\n      - {label: \"Layout\", name: \"layout\", widget: \"hidden\", default: \"post\"}\n      - {label: \"Title\", name: \"title\", widget: \"string\"}\n      - {label: \"Publish Date\", name: \"date\", widget: \"datetime\"}\n      - {label: \"Tags\", name: \"tags\", widget: \"list\", required: false}\n      - {label: \"Categories\", name: \"categories\", widget: \"list\", required: false}\n      - {label: \"Photos\", name: \"photos\", widget: \"list\", required: false}\n      - {label: \"Excerpt\", name: \"excerpt\", widget: \"string\", required: false}\n      - {label: \"Body\", name: \"body\", widget: \"markdown\"}\n      - {label: \"Permalink\", name: \"permalink\", widget: \"string\", required: false}\n      - {label: \"Comments\", name: \"comments\", widget: \"boolean\", default: true, required: false}\n```\n\nindex.html\n\n```\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>Content Manager</title>\n</head>\n<body>\n  <!-- Include the script that builds the page and powers Netlify CMS -->\n  <script src=\"https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js\"></script>\n  <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n</html>\n```\n\n### Netlify 端配置\n\n#### 创建 Netlify website\n\n注意：和大部分人的做法不同的是，我Deploy到的地方并不是托管在Netlify自己的平台上，而是github上，所以这里我选择部署的是Source分支，而不是Master，因为我只是想要Netlify去修改我的Source分支，然后触发Travis自动发布到Master分支。\n\n但是我依旧需要填写Netlify的部署，因为Netlify会自动帮我创建域名为troyyang.netlify.com的网站，任何我Source分支上的修改也会触发这个网站的自动部署\n\n![](/images/uploads/2019-11-24-create-netlify-website.png)\n\n#### 开启Netlify Identity 和 Git Gateway\n\n在Setting 的 Identity选项下：\n\n1. Enable Identity service\n2. External providers 新增github\n3. Enable Git Gateway\n\n### 发布测试\n打开 https://troyyang.netlify.com/admin/ 然后使用github Oauth登录即可看到：\n\n![](/images/uploads/2019-11-24-netlify-home.png)\n\n![](/images/uploads/2019-11-24-netlify-create.png)\n\n新增文章后， 你会发现github 上的source目录下的_post 目录的markdown 文件新增了，如果上传了图片，也会看到source目录下多了images/upload目录，同时https://troyyang.netlify.com 和 https://troyyang.com 下也自动发布了新的文章, 两者都是因为Source分支里新增了文件导致的自动部署。\n\n![](/images/uploads/2019-11-24-netlify-file-structure.png)\n![](/images/uploads/2019-11-24-troyyang.png)\n![](/images/uploads/2019-11-24-netlify.png)\n\n### 问题\n当我尝试打开 https://troyyang.com/admin/ 使用github Oauth登录时，结果报错，而https://troyyang.netlify.com/admin/则没有：\n```\nFailed to load settings from /.netlify/identity\n```\n![](/images/uploads/2019-11-24-netlify-admin-error.png)\n\n我怀疑是因为https://troyyang.com是托管在github上，而不是netlify上导致的。\n\n\nEnjoy!\n","tags":["netlify"],"categories":["web"]},{"title":"AWS系列之使用无服务器架构你的网站","url":"/2018/12/16/aws_serverless/","content":"***\n### Serverless 有什么用啊？\nJason最近又出新想法了，想要做一个简单的用户管理系统，好的，没问题，不就是在服务器上安装数据库，部署好网站吗？可答案是no，他不是专业人员，我也不可能永远维护这个服务器，更重要的是服务器开着就要美刀啊，还不能停，怎么办？有没有可以不用服务器的网站，有啊，你自己的静态博客不就是只用到了s3或者github的静态页面托管吗？可是数据库呢，后台api呢？额，这个嘛。。。   \n\n好了，成功引出话题，要知道这是21世纪的云时代，只有你想不到，没有做不到的，这不，AWS早就提出了[Serverless](https://aws.amazon.com/cn/serverless/?nc1=h_ls)解决方案：S3 + GateWay API + Lambda + DynamDB，其中举例的一个天气的app架构：\n\n![image](https://images.troyyang.com/2018-12-16-Lambda-WebApplications.png)\n\n其中s3做静态页面托管，用户触发点击事件，调用Gateway API提供到接口，接口映射到Lambda服务端接口，Lambda再负责去处理和数据库相关到操作。整个过程不需要服务器，而且费用是极低的，按量付费，可扩展性也很强，基本做到可配置化。说了这么多，还是得用过才知道好不好。\n\n### 实现思路\n1. 服务端RestFull： Node express 实现RestFull API\n2. 创建lambda并上传服务端代码\n3. 配置API Gateway映射到lambda函数\n4. 客户端实现： Bootstrap 实现登录 和 管理页面\n5. 修改客户端api接口地址并上传至S3\n\n其中，到第三步的时候我们就已经创建好了一个完整的无服务器的 Restfull API，剩下的就是客户端调用了，客户端调用这个就可以是五花八门的了，这也不是本篇文章的重点。\n\n### 简单 RestFull 服务端实现\n服务端的实现和平时实现一个Node RestFull api的完全没有任何区别, 部分代码如下:\napp.js\n```\n'use strict';\n\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cors());\n\nlet contacts = require('./data');\n\napp.get('/api/contacts', (request, response) => {\n  if (!contacts) {\n    response.status(404).json({ message: 'No contacts found.' });\n  }\n  response.json(contacts);\n});\n\nconst hostname = 'localhost';\nconst port = 3001;\nconst server = app.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n\nmodule.exports = app\n\n```\n\n这一步做完，确保所有接口都能通过访问 localhost:3001/api/contacts\n\n![image](https://images.troyyang.com/2018-12-16-restful-success.png)\n\n### aws-serverless-express\n要使得上面的服务端代码能在lambda中允许，只需借助 npm 包[aws-serverless-express](https://github.com/awslabs/aws-serverless-express)\n\n在目录下新增 lambda.js文件\n```\n// lambda.js\n'use strict'\nconst awsServerlessExpress = require('aws-serverless-express')\nconst app = require('./app')\nconst server = awsServerlessExpress.createServer(app)\n\nexports.handler = (event, context) => awsServerlessExpress.proxy(server, event, context)\n```\n这也是为什么我们要在 app.js最后一行exports的原因\n```\nmodule.exports = app\n```\n此时，将所有文件包括node_module目录全部打包为.zip 文件为后面使用。\n### 创建 lambda\n#### 创建 IAM role\n创建 Lambda的IAM Role是必须的，他指定了当前lamda能访问到的资源有那些，从我们的列子中，我们需要用到DynamoDB, 同时为了方便debug，我们还需要用到cloudwatch服务 （这个对于查找问题非常有用）。\n\n登录aws console，打开 Service 找到 IAM ，再选择Roles，点击 create role 按钮 后如图，(第三步可选)：   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step1.png)   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step2.png)   \n![image](https://images.troyyang.com/2018-12-16-lambda-create-role-step4.png)   \n\n#### 创建 lambda 函数\n打开Service 找到lambda, 选择 create function：   \n![image](https://images.troyyang.com/2018-12-16-create-lambda.png)\n\n创建后，在代码输入种类中选择上传 .zip 文件：   \n![image](https://images.troyyang.com/2018-12-16-lambda-manage.png)\n\n将服务端代码整个打包 （注意一定要包括packages目录下的所有文件）然后上传，大小不能超过10m，如果超过了，可以在代码输入种类选择s3上传。上传完成后，指定入口文件（即在处理程序）为 lambda.handler， 此文件将会映射到 lambda.js文件，一般情况，如果上传的zip包不是很大，aws会自动列出zip项目目录可供在线编辑，但如果大了的化，比如好几兆，则有可能不会列出项目目录，每次修改又只能重新上传。\n\n![image](https://images.troyyang.com/2018-12-16-lambda-list-file.png)\n\n当然，如果node 代码里包括了一些环境变量，你也可以为 lambda 做一些环境变量的设置：\n\n![image](https://images.troyyang.com/2018-12-16-lambda-env.png)\n\n一切ok后，就可以测试了，关于lambda的测试，则相对还比较麻烦，我也是最近才稍微懂那么一点。\n#### 测试 lambda 函数\n\n在创建好的lambda 函数旁，点击配置测试事件按钮，在弹出对话框创建测试事件中选择创建新测试事件，在事件模板中选择 Amazon API Gateway AWS Proxy, 并给个测试名称，如图：\n![image](https://images.troyyang.com/2018-12-16-lambda-create-test.png)\n\n选择Amazon API Gateway AWS Proxy是因为我们的这个lambda函数最终会被API Gateway 触发调用，同时由于默认的事件模板是 post 的请求方式，而我们的这个服务端只有一个api/contacts的get方法，所以我们需要更改事件内容为：\n```\n{\n  \"resource\": \"/{proxy+}\",\n  \"path\": \"/api/contacts\",\n  \"httpMethod\": \"get\",\n  \"headers\": {\n    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n    \"Accept-Encoding\": \"gzip, deflate, sdch\",\n    \"Accept-Language\": \"en-US,en;q=0.8\",\n    \"Cache-Control\": \"max-age=0\",\n    \"CloudFront-Forwarded-Proto\": \"https\",\n    \"CloudFront-Is-Desktop-Viewer\": \"true\",\n    \"CloudFront-Is-Mobile-Viewer\": \"false\",\n    \"CloudFront-Is-SmartTV-Viewer\": \"false\",\n    \"CloudFront-Is-Tablet-Viewer\": \"false\",\n    \"CloudFront-Viewer-Country\": \"US\",\n    \"Host\": \"1234567890.execute-api.ap-northeast-1.amazonaws.com\",\n    \"Upgrade-Insecure-Requests\": \"1\",\n    \"User-Agent\": \"Custom User Agent String\",\n    \"Via\": \"1.1 08f323deadbeefa7af34d5feb414ce27.cloudfront.net (CloudFront)\",\n    \"X-Amz-Cf-Id\": \"cDehVQoZnx43VYQb9j2-nvCh-9z396Uhbp027Y2JvkCPNLmGJHqlaA==\",\n    \"X-Forwarded-For\": \"127.0.0.1, 127.0.0.2\",\n    \"X-Forwarded-Port\": \"443\",\n    \"X-Forwarded-Proto\": \"https\"\n  }\n}\n```\n保存测试事件，并点击执行，如果一切正常，会得到如下:\n![image](https://images.troyyang.com/2018-12-12-lambda-test-success.png)\n\n### 创建 API Gateway\n找到Service下到API Gateway，并点击新建 api,   \n\n![image](https://images.troyyang.com/2018-12-16-create-api-gateway.png)   \n新增 api 资源（路径）   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-api-source.png)   \n选择 api 资源，再新增子资源，并选为proxy   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-source.png)   \n选择 proxy 资源，创建 集成环境为我们创建好的lambda 函数   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-create-method.png)   \n\n创建完成之后，在操作选项中，选择部署，弹出对话框并命名为dev阶段：   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy.png)   \n\n部署完成后，得到如下结果：   \n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy-success.png)\n\n### API Gateway 测试\n在部署完成后，我们会在上述结果中得到发布出来的api 地址为  \n>https://ijihnuupmh.execute-api.ap-northeast-1.amazonaws.com/dev\n\n此时如果直接访问，会得到Missing Authentication Token的错误，原因是我们地址不对\n```\n{\"message\":\"Missing Authentication Token\"}\n```\n正确地址应该为:\n>https://ijihnuupmh.execute-api.ap-northeast-1.amazonaws.com/dev/api/contacts\n\n![image](https://images.troyyang.com/2018-12-16-api-gateway-deploy-url-success.png)   \n\n由于上述地址是永久的，除非你重新部署，所以我们可以放心的使用用来作为api地址。还有一个就是API Gateway似乎是不收取费用的，只会按照lambda\b函数的调用\b次数来收取费用，好像每月前100万次请求是免费的。\u001c所以还是相当划算。\n\nOK! 一个无服务器的后端 api 就这样搭建好了，剩下的就是前端静态资源的托管了\n\n### 前端静态资源\n\b直接上传html,js,css 等静态资源到S3就好了，具体可以参见另一篇博客 [AWS系列之S3 + Cloudfront搭建https静态网站](https://troyyang.com/2018/05/12/aws_s3_https_static_website/)\n\n","tags":["serverless"],"categories":["aws"]},{"title":"AWS系列之S3 + Cloudfront搭建https静态网站","url":"/2018/05/12/aws_s3_https_static_website/","content":"***\n\n本文和之前写的[《正确使用AWS S3的方式之打造自己的https图床》](https://troyyang.com/2018/02/16/hosting-images-with-aws-s3/) 内容非常像，但也有新的内容如自动上传部署和自定义证书、Route53部分，这里主要补充新的内容。\n\n### 温馨提醒\n1. 个人用户请注册AWS 全球账号，因为AWS 中国账号似乎只对企业开发而无法注册。\n2. AWS S3默认地址中国无法访问，需要使用Cloudfront的新地址才能访问，而且访问速度不慢，你能感觉到我博客的图片加载慢吗？\n3. S3、Cloudfront、Route53等收费异常的低，几乎可以忽略。\n\n### 架构概述\n![image](https://images.troyyang.com/2018-5-12-myenglishtutor-s3.png)\n采用Hexo作为静态网站生成器，主题使用的正是我自己开发的hexo-theme-twentyfifteen-wordpress，整个网站代码托管在github的私人repo下。当写好文章后，使用Hexo生成静态代码html+css+js+image，并使用写好的s3 SDK 上传工具到指定aws 的存储桶里进行静态托管 （之前使用的是github的Travis 自动部署，但由于私人Repo需要收费，于是放弃Travis改用自己的工具上传）。上传到S3里之后，使用Cloudfront做内容分发，并绑定自定义的https证书，最后，使用Route53做自定义域名的绑定。\n\n### 生成 IAM access key 用户子账号 \n此账号可用于编程的方式访问AWS 的所有指定资源，这里我们创建的IAM 账号只需要有S3的读写权限\n\n进入 https://console.aws.amazon.com/iam/home?region=ap-northeast-1#/users\n\n选择add user后， 一定要选择programmatic access这种编程方式的子账号，而另一个console账号针对的是用户名，密码登录的子账号\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step1.png)\n\n指定该账号可访问的权限\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step2.png)\n\n保存access id和key\n![image](https://images.troyyang.com/2018-5-12-aws-iam-step4.png)\n\n### 使用S3 SDK自动上传\n默认情况下，所有Hexo编译后的文件都放在public文件件下，所以只需要拷贝到S3 存储桶下，当然可以手动拷贝，但是实在太麻烦。所以写了个node tool去自动上传（部署）。\n\n[下载](https://gist.github.com/Troy-Yang/436a62fb14d9e07e1aa3534f1c351050)\n--s3-deploy\n------config.json\n------index.js\n\nconfig.js 里包括的是AWS AMI 账号信息，确保region使正确的区域, 具体参考[区域列表](https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)\n```\n{\n    \"accessKeyId\": \"xxxxxx\",\n    \"secretAccessKey\": \"xxxxx\",\n    \"region\": \"ap-northeast-1\" \n}\n```\n\nindex.js，其中myenglishtutor.eu是存储桶的名字(命名的时候请用域名)\n```\nvar path = require(\"path\");\nvar fs = require('fs');\nvar mime = require('mime');\nvar AWS = require('aws-sdk');\nAWS.config.loadFromPath('./s3-deploy/config.json');\nlet s3 = new AWS.S3();\n\nconst uploadDir = function (s3Path, bucketName) {\n    function walkSync(currentDirPath, callback) {\n        fs.readdirSync(currentDirPath).forEach(function (name) {\n            var filePath = path.join(currentDirPath, name);\n            var stat = fs.statSync(filePath);\n            if (stat.isFile()) {\n                callback(filePath, stat);\n            } else if (stat.isDirectory()) {\n                walkSync(filePath, callback);\n            }\n        });\n    }\n\n    walkSync(s3Path, function (filePath, stat) {\n        let bucketPath = filePath.substring(s3Path.length + 1);\n        let mimeType = mime.getType(bucketPath);\n        let params = { \n            Bucket: bucketName, \n            Key: bucketPath.replace(/\\\\/g, '/'), \n            Body: fs.readFileSync(filePath),\n            ContentType: mimeType\n        };\n        s3.putObject(params, function (err, data) {\n            if (err) {\n                console.log(err)\n            } else {\n                console.log('Successfully uploaded ' + bucketPath + ' to ' + bucketName);\n            }\n        });\n    });\n};\n\nuploadDir(\"public\", \"myenglishtutor.eu\");\n```\n\n最后在package.json文件中，添加运行脚本：\n```\n  \"scripts\": {\n    \"start\": \"hexo clear & hexo g & hexo server\",\n    \"deploy\": \"hexo clear & hexo g & node ./s3-deploy/index\"\n  },\n```\n\n### 使用Travis 自动部署\n如果代码是托管到github上或者支持Travis的服务，可以是用下面的.travis.yml配置达到CI, CD，请在travis.org中配置好环境变量$AWS_ACCESS_ID， AWS_SECRET_KEY，AWS_REGION\n```\nlanguage: node_js\nnode_js: stable\n\nscript: true\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n\nbefore_install:\n  - git submodule update --init --remote --recursive\n  \n#before_script:\n # - npm install -g gulp\n\nscript:\n  - hexo g\n# E: Build LifeCycle\n\n\nbefore_deploy:\n  # - zip -r latest *\n  # - mkdir -p dpl_cd_upload\n  # - mv latest.zip dpl_cd_upload/latest.zip\n  - cp -a source/.well-known public/\n\ndeploy:\n  - provider: s3\n    access_key_id: ${AWS_ACCESS_ID}\n    secret_access_key: ${AWS_SECRET_KEY}\n    local_dir: public\n    skip_cleanup: true\n    on:\n      repo: Troy-Yang/troy-yang.github.io\n      branch: source\n    bucket: troyyang.com\n    region: ${AWS_REGION}\n```\n\n### https自定义证书\n想要支持https，那么证书是必须的，可以直接开启cloudfront，默认就会添加cloufront生成证书，如\n![image](https://images.troyyang.com/2018-2-18-distribution-overview.png)\n\n如果想要自定义证书，则需要自己在ACM(AWS Certificate Manager)申请证书，并做txt域名验证，一切ok后则会得到：\n![image](https://images.troyyang.com/2018-5-12-aws-myenglishtutur-acm.png)\n\n申请步骤如下：\n进入 https://console.aws.amazon.com/acm/home?region=us-east-1#/wizard/ \n填写域名:\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step1.png)\n选择验证方式：（DNS验证方便，Email没试过，好像很麻烦）\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step2.png)\n拷贝name和value值，保存并在DNS服务器中添加CNAME记录，如果DNS是使用AWS自家的Route53，则非常方便，只需要在相应的Domain下，添加 Record Set 记录, 类型选择CNAME。如果是在万网或者Cloudflare，也是非常方便的。\n![image](https://images.troyyang.com/2018-5-12-aws-acm-step4.png)\n记录添加好后，等待验证通过后（大概几至十几个小时后），状态从pending 变为 issued，就说明证书通过，该域名已合法。\n![image](https://images.troyyang.com/2018-5-12-aws-acm-list.png)\n\n#### Cloudfront 中使用自定义证书\n证书有了之后，只需要将其添加到创建的Cloudfront中就可以了\n![image](https://images.troyyang.com/2018-5-13-aws-acm-cloudfront.png)\n\n请注意选择Custom SSL Certificate, 然后输入框中，AWS会自动列出可用的证书列表，如果没有，则点击Request or Import a certificate with ACM 选择上面新增的就好了\n在浏览器访问这个cloudfront地址，就可以看到https的标志，查看这个https证书就可以得到自定义的这个域名，而不是cloudfront开头的，看起来是不是很高大上。\n\n#### 绑定Cloudfront 到自定义DNS\n上面的cloudfront地址如果用于提供API之类的接口地址倒是无所谓， 但是如果是别人访问的地址，那肯定不行的，还需要添加一条A记录，将自己的域名和上述地址进行绑定。同理，如果是在Route53，只需要添加一条A记录就好了，大致如图：\n![image](https://images.troyyang.com/2018-5-13-aws-dns-cloudfront.png)\n\n保存后，过几分钟就可以通过自己域名，访问到S3中的内容，并且证书显示的是自己域名。\n![image](https://images.troyyang.com/2018-5-12-aws-myenglishtutur-acm.png)","tags":["aws"],"categories":["aws"]},{"title":"AWS系列之 myenglishtutor基于AWS生态的广泛使用","url":"/2018/05/12/aws_structure_series/","content":"***\n### 写在开头\n看着系统生成的写作时间，2018年5月12日，恐怕是让所有四川人都难以忘怀的日子，在此缅怀十年前大地震遇难的同胞，也希望曾遭受苦痛的同胞十年后的今天一切安好！\n\n回想在给Jason兼职工作的这半年多，一个人把 ![image](https://myenglishtutor.eu/images/icons/favicon-32x32.png) [https://myenglishtutor.eu](https://myenglishtutor.eu) 从0到1的把网站一点一点建好，感觉像个自己的孩子，总想要给他最好的，但也由于个人精力有限，很多想做的都没去做。尤其是AWS的生态让我印象深刻，所以想要写下这一个系列的技术感悟。\n\n|<h2>[AWS系列之S3 + Cloudfront搭建https hexo静态网站](https://troyyang.com/2018/05/12/aws_s3_https_static_website/)</h2>|\n|:---------|\n|使用hexo做静态内容生成，s3托管静态网站内容，使用cloudfront做内容分发及https证书自动生成，route53做域名DNS解析，还有部分工具如依托s3 SDK做代码自动上传部署，google driver 自动同步等。|\n|hexo、s3、cloudfront、route53、certification、aws s3 SDK auto sync file and deployment|\n\n|<h2>[AWS系列之 Stripe 国际支付](https://troyyang.com/2018/01/21/stripe_guide_alipay/)</h2>|\n|:---------|\n|服务端使用Lambda、API Gateway实现的无服务器服务，客户端使用Stripe的Element.js类库|\n|Lambda、API Gateway|\n\n|<h2>AWS系列之结合OpenTek实现多人实时Web视频通话、教学</h2>|\n|:---------|\n|使用s3做视频前端和后台管理的代码托管, Lambda+DynamoDB+API Gateway实现Serverless搭建的node express无服务器服务端。|\n|s3、openTek SDK、Lambda、DynamoDB、API Gateway、Angular 1.0、bootstrap|\n\n|<h2>AWS系列之Polly服务实现AI文本到语音翻译</h2>|\n|:---------|\n|使用aws的Polly服务实现文本转语音的翻译，服务端搭建的Serverless服务端，客户端使用自己写的hexo plugin功能调用API。|\n|Lambda、API Gateway、SNS、s3、Hexo plugin|\n\n|<h2>AWS系列之使用Wowza streaming实现视频直播+弹幕服务</h2>|\n|:---------|\n|架构上使用EC2负载均衡和自动扩容实现可伸缩视频直播服务。弹幕使用web socket实现双向通信，客户端采用对手机H5播放支持。|\n|s3、EC2、Load banance、ASG、cloudfront、linux、 danmaku、h5 video|\n\n\n这里也打个广告简单介绍一下Jason和他的myenglishtutor，从名字也大概知道他是个英语老师和他的个人网站，Jason是个地道的英国人，浓厚的英国口音以及超过十几年英语专业教学经验，作为myenglishtutor的开发者，我为他集成了包括视频直播，1对1，1对多的视频教学直播，支付宝支付，词法解释等功能，所以不用担心教学方式及支付等问题。如果有意专业英语要求的个人或者团体，欢迎直接联系我，有更低的折扣等你。\n\n","tags":["aws"],"categories":["aws"]},{"title":"正确使用AWS S3的方式之打造自己的https图床","url":"/2018/02/16/hosting-images-with-aws-s3/","content":"***\n\n写过博客的人都知道图床，一个托管自己博客图片的地方，当然托管到自己的服务器另当别论。常见的图床可以是新浪博客，七牛云，imgur等，但是都是有各种问题，比如我之前使用的是七牛云（也曾在[《给Github自定义域名加上HTTPS》](https://troyyang.com/2017/05/21/Add_Free_Certification_In_Blog_Step_By_Step/)博文上推荐使用），用起来相当不错，只可惜后来备案信息过期了，导致无法再使用自定义域名，更可悲的是，https不再支持，意味着尽管我的博客是https但由于有内容是http的，只能被浏览器认为是mixed-content的。\n\n但是，前几天无意发现一片新大陆，使用aws s3结合cloudfront distribution 可以借助亚马逊云无缝快速托管自己的图片还自带https，而费用几乎是很小的，按量收费。\n\n### 步骤概述\n（如果不需要有自定义图片的域名，第三步可选）\n1. 创建一个图片s3 bucket并公开。\n2. 创建cloudfront distribution并绑定S3 bucket和默认证书以支持https\n3. 在DNS服务商（我的是cloudflare）创建图床域名，并绑定cloudfront域名地址 \n\n### 全球亚马逊 Or 亚马逊中国？\n两者区别好像挺大的，后者曾经注册过，但是不知为什么没通过审核，可能需要公司邮箱吧。并且，如果考虑到备案等因素，建议使用全球亚马逊。（需要绑定VISA信用卡）   \n全球亚马逊地址是：https://console.aws.amazon.com/console/home\n\n### 创建S3 Bucket（存储桶）\n账号创建成功后，进入S3控制台https://s3.console.aws.amazon.com，存储桶名称以待托管域名命名，比如我的是 images.troyyang.com，其他项首先都选择默认，待会再一项一项改。\n![image](https://images.troyyang.com/2018-2-18-s3-bucket.png)\n#### 访问权限设置\n\n在存储桶的权限页面，选择存储桶策略，键入下面的值：\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"PublicReadForGetBucketObjects\",\n            \"Effect\": \"Allow\",\n            \"Principal\": \"*\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::images.troyyang.com/*\"\n        }\n    ]\n}\n```\n![image](https://images.troyyang.com/2018-2-18-aws-s3-permission.png)\n#### 静态托管\n存储桶创建成功后，进入属性页面，选择静态网站托管，键入索引文件index.html，错误文档error.html，然后保存。此时，公共访问页面已经生成，终端节点如下：\nhttp://images.troyyang.com.s3-website-ap-northeast-1.amazonaws.com\n\n![image](https://images.troyyang.com/2018-2-18-aws-s3-static-host.png)\n上传自己的所有图片在此存储桶下，然后加上文件后缀就应该可以访问了，然而现实是残酷的，在我大天朝下，这个地址有时候是无法访问当的 。。。WTF。。。于是，得进行下面的自定义域名步骤\n\n### CloudFront Distribution\n上面地址是AWS自动生成的访问域名，并且只支持http，想要支持https，并且绑定自定义域名（images.troyyang.com），需要使用到CloudFront Distribution。\n\nCloudFront Distribution 是AWS的内容分发（CDN）使得全球各地都能以最快的速度访问到AWS最近的节点（对于中国，最近的是东京，经测，也已经足够快），并且可绑定或者生产SSL证书。\n\n#### 创建 Distribution\n打开 https://console.aws.amazon.com/cloudfront/home， 选择Create Distribution, 传输方式选择Web选项 Get Started，在很多选项中，主要注意几项就好了（都是可后期修改）：\n- Origin Domain Name中选择刚才所建的S3 Bucket 域名\n- Alternate Domain Names(CNAMEs)填写自定义域名(没有的话，可不管)， 这里是 images.troyyang.com\n- SSL Certificate 暂时选默认Default CloudFront Certificate (*.cloudfront.net)\n- Price Class 可以只选择Use Only US, Canada, Europe and Asia\n\n![image](https://images.troyyang.com/2018-2-18-aws-create-distribution.png)\n\n一切配置好后，静静等待几个小时就会看到Distribution部署成功，大致结果如下：\n\n![image](https://images.troyyang.com/2018-2-18-distribution-overview.png)\n\n此时，得到Distribution 的新访问地址 d2dxo9yo9kwqp2.cloudfront.net，这个时候，我们找一张在S3中存在的图片，加上https再次访问 https://d2dxo9yo9kwqp2.cloudfront.net/2017-5-21-https.png 一切OK\n\n#### 自定义证书（可选）\n上面的证书是亚马逊自己提供，如果想要使用绑定自己的域名证书，可以使用AWS的Certificate Manager 证书服务，在自己的DNS服务商比如万网或者阿里云那里配置好验证方式，具体操作方法参考 https://docs.aws.amazon.com/zh_cn/acm/latest/userguide/gs-acm-request.html 。因为我暂时觉得没必要，所以没使用上。\n\n### 绑定自定义域名（可选）\n上面的是cloudfront分发的一个地址，虽然地址是固定的，但毕竟不是自家的域名，感觉不高大上，所以需要绑定上自己的图片域名。\n\n由于我的DNS服务解析改为了Cloudflare，所以是以Cloudflare的来配置的域名，但和万网或者阿里云的配置完全一致，在DNS解析项中添加一条CNAME记录，指向Cloudfront分配的域名即可\n\n![image](https://images.troyyang.com/2018-2-18-dns-image.png)\n等待绑定解析成功后，访问 https://images.troyyang.com/2017-5-21-https.png ，一切OK\n","tags":["s3"],"categories":["aws"]},{"title":"Stripe开发使用指南--国际支付（含支付宝）","url":"/2018/01/21/stripe_guide_alipay/","content":"***\n前段时间，因为Jason让我帮忙把Stripe支付集成到他个人网站上去，让我有机会接触到支付系统开发，同时也因为苦于没有找到太多中文方面相关文档介绍，所以做个总结，也方便以后有需要的同学。   \n(更新) 发现好些同学也在咨询如何集成微信支付，其实也是非常简单，所以新增了最后微信的实现，见最后\n\n### 关于Stripe支付\n\n第一次听说Stripe还是在几个月前的一个新闻上了解到，大致说的是美国总统都在使用它，极有可能成功下一个Paypal。这么受欢迎的一个支付平台到底有什么好处呢？我粗略搜集了一下：\n\n- 一条代码让你网站支持繁琐的国际支付功能。（对于创业公司，再合适不过）\n- 向全球化业务拓展会成为Stripe的机会。即使支付货币不同、方法不同，Stripe都能打通各自的渠道，让全球化交易不受支付阻碍。\n- 市值超过90亿美元，和Tweeter,Lyft，Best Buy等以及国内的 Alipay, WeChat等有合作\n\n重点说下第二点，什么意思呢，就是说客户可以使用人民币支付，如果商家（收款方）是美国的银行的话，就自动转成美元，是英国的银行就自动转为英镑！（**可惜暂时不支持商家是中国（但Stripe也可提供解决方案，就是使用Atlas去创建一个美国的代理公司）**）\n\n而对于我们程序员的话，当然最关心第一条，因为他的宗旨就是开发极简，对开发人员超级友好！至于多友好呢，请往下看。\n\n### 最简洁支付\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Stripe Checkout</title>\n</head>\n<body>\n   <form action=\"/your-server-side-code\" method=\"POST\">\n  <script\n    src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"\n    data-key=\"[Publishable key]\"\n    data-amount=\"999\"\n    data-name=\"troy yang\"\n    data-description=\"Widget\"\n    data-image=\"https://stripe.com/img/documentation/checkout/marketplace.png\"\n    data-locale=\"auto\"\n    data-zip-code=\"true\"\n    data-currency=\"eur\">\n  </script>\n</form>\n</body>\n</html>\n```\n就这么几行代码，我们就已经实现了客户端所有事：\n\n![image](https://images.troyyang.com/2018-1-13-stripe-checkout.png)\n\n真的是超级简单，但是这种方式是基于信用卡支付的界面，已经可以满足一半的支付方式，对于其他的三方支付，比如3D secure， 支付宝，微信，甚至比特币，Stripe为我们提供了其他方式，等下我就使用支付宝来举例。\n\n### 注册 Stripe 账号\n和注册支付宝账号一个道理，首先注册账号，然后绑定自己银行卡，BUT, 就像前面提到的，不支持中国，所以就算注册成功，也没法激活，也就没法收款。\n![](https://images.troyyang.com/2018-1-13-stripe-support-countries.PNG)\n\n对于中国商家怎么办呢，我能想到的就只有这几个办法：\n- 自己去支持国家去办理张银行卡\n- 使用国外的朋友银行卡\n- 使用Atlas\n\n对于Jason来说，因为他是英国人，所以他可以创建他的主账号，然后添加我的stripe账号到他team memeber账号列表中，这样我就可以访问他账户下所有开发者需要的权限。邀请成功后，Dashboard页面\n\n### 两个阶段\n\nStripe有两种模式，一个是测试模式(Test Mode)，一个是生产模式(Live Mode)，测试模式下产生的金钱交易都只用于测试，当所有测试通过后即可切换为Live模式。唯一的不同就是**Publishable key** 和 **Secret key**， 一会我们会用到这两个值。\n![image](https://images.troyyang.com/2018-1-13-stripe-test-mode.PNG)\n\n### 交易流程\nStripe有几个概念用于整个交易阶段和状态：\n![image](https://images.troyyang.com/2018-1-18-workflow.png)\n\n#### 创建 Source\n\n使用自己的**Publishable key**来创建一种source（比如Cards, 3D Secure, 支付宝，甚至比特币等）, 创建source完了后，就会得到一个用于交易的Token或者是一个跳转到其他支持的三方支付平台（比如支付宝支付）页面等待用户支付。当用户支付（或者取消支付）完成，自动跳转回到指定结果页面。用户支付页面结束后，可能会得到三个状态：\n\n- source.chargeable 用户授权（支付）成功\n- source.failed 用户拒绝授权（支付）\n- source.canceled 超时支付\n\n#### 创建 Charge\n当用户支付成功后，此时在Stripe端的支付状态变为source.chargeable，意思就是授权成功了，你可以在我支付宝平台上扣钱啦，所以，此时我们还需要使用**Secret key**来创建Charge来完成，官方推荐的是使用webhooks来捕捉状态，并且完成Charge的创建。当Charge完成后，整个支付完成，会得到一个charge.succeeded的状态。\n\n#### 使用 webhooks\nWebhooks 里提供了几十种状态，所有这些状态都会注册到Stripe里一个叫webhooks事件钩子的地方，我们可以指定不同事件的触发时，转发数据到某个我们自己搭建好的Web Api上。（下图是我们的服务器end point, 因为我们没有用到服务器，使用的是亚马逊lambda做一个Serverless）\n![image](https://images.troyyang.com/2018-1-18-web-hooks.png)\n\n## 举个支付宝的栗子\n\n### 服务端 （Serverless）\n以AWS的Lambda + API gateway为例， 其中，前者是用来定义API， 后者是做路由。\n![image](https://images.troyyang.com/2018-1-18-lambda.png)\n\n![image](https://images.troyyang.com/2018-1-18-lambda-source-chargeable.png)\n\n![image](https://images.troyyang.com/2018-1-18-lambda-variable.png)\n\n创建Charge代码：\n```\n'use strict';\n\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\nexports.handler = (event, context, callback) => {\n    console.log(\"request: \" + JSON.stringify(event));\n\n    let stripeData = event.data.object;\n    stripe.charges.create({\n        amount: stripeData.amount,\n        source: stripeData.id,\n        currency: stripeData.currency || 'usd',\n        description: 'My Englishtutor 30 days' || ('Stripe payment ' + event.id),\n    }, function(err, charge) {\n        if (err && err.type === 'card_error') {\n            context.fail(new Error(err.message));\n        }\n        else if (err) {\n            context.fail(err);\n        }\n        else {\n            context.succeed({ status: charge.status, success: true });\n        }\n    });\n};\n```\n\n\n### 客户端 (Web)\n多种实现方式：\n#### Checkout\n文章开头那段<form>的集成代码就是使用的checkout方式，非常简单。集成代码直接帮你完成了客户端的部分，服务端只需要定义好source.chargeable的钩子API 就好了。\n\n在做支付宝开发的时候，发现可以直接使用Checkout的方式：\n```\n<form action=\"https://xxx.execute-api.eu-central-1.amazonaws.com/stripepayment/xxx\" method=\"POST\">\n  <script\n    src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\"\n    data-key=\"pk_test_xxx\"\n    data-amount=\"30000\"\n    data-name=\"myenglishtutor.eu\"\n    data-label=\"Pay With Alipay\"\n    data-description=\"30 days\"\n    data-image=\"/images/logo.png\"\n    data-locale=\"auto\"\n    data-alipay=\"auto\"\n    data-currency=\"usd\">\n  </script>\n</form>\n```\n但是总是得到这个错误：\n```\nUnrecognized request URL (POST: /v1/alipay/send_sms). Please see https://stripe.com/docs or we can help at https://support.stripe.com/.\n```\n![image](https://images.troyyang.com/2018-1-21-alipay-checkout.png)\n\n发邮件给Stripe support team得到的结果是为了以后的扩展，Stripe不再提供alipay的checkout方式， 无奈，只得使用下面的方式。\n#### Stripe.js & Elements\n当然对于如果你觉得Checkout的方式集成度太高，不够灵活，那Stripe.js是你最好的选择。\n\nStripe.js其实就是客户端的一个JS核心类库，Elements是它的UI类库，其实上面的Checkout代码就是Stripe使用两者给我们封装好了的，避免我们直接接触敏感信息，但是其实质都是一样的，都是用来创建source。这里就直接贴出客户端的代码了(这里没有用到Elements做UI，因为就是一个按钮支付，太简单，所以没用到)：\n```\nvar stripe = Stripe('pk_live_xxxx');\n\nfunction alipay(amount) {\n    showLoading();\n    stripe.createSource({\n        type: 'alipay',\n        amount: parseInt(amount),\n        currency: 'gbp', // usd, eur,\n        redirect: {\n            return_url: 'https://xxx.eu/pay/result.html'\n        },\n    }).then(function (response) {\n        hideLoading();\n        if (response.error) {\n            alert(response.error.message);\n        }\n        else {\n            processStripeResponse(response.source);\n        }\n    });\n}\n\nfunction processStripeResponse(source) {\n    window.location.href = source.redirect.url;\n}\n```\n![image](https://images.troyyang.com/2018-1-21-alipay-console.png)\n\n\n这里需要注意几点：\n- currency 必须是Stripe账号所在地货币，也就是绑定的银行卡所在地，因为Jason是英国人，所以必须使用gbp（这里愚蠢如我的犯了一个常识错误，一直以为英国也是欧盟的，所以使用eur，结果怎么也不对，直接哭晕在厕所）\n- return_url指向的是当用户重定向到我们常见的支付宝支付页面后，跳转回支付完成的页面，在这个返回页面中，因为支付宝是同步完成支付的，所以我们可以去查询charge.succeeded的状态来判定是否用户支付是否完成。\n\n\n当一切OK，点击支付按钮，就会跳转到支付宝支付页面(其他支持的三方平台也可以)，如下：\n![image](https://images.troyyang.com/2018-1-23-alipay-success.png)\n\n### 微信实现\n其实也非常的简单，只需要将上一步的type改为wechat，同时返回source中的source.wechat.qr_code_url转为二维码就好了\n```\nvar wechatCallback = function (source) {\n    generateQRCode(source.wechat.qr_code_url);\n}\nfunction generateQRCode(value) {\n    var qrEle = document.getElementById(\"qrcode\");\n    var qrcode = new QRCode(qrEle, {\n        width: 100,\n        height: 100\n    });\n    qrcode.makeCode(value);\n    qrEle.style.display = 'inline-block';\n}\n```\n二维码出来后， 扫码就会得到如下结果   \n![image](https://images.troyyang.com/2018-12-16-wechat-success.jpeg)\n","tags":["finance"],"categories":["Web"]},{"title":"成都持续交付大会","url":"/2017/12/10/cdconf/","content":"抽空记录一下2017年11月18日中国第十三届持续交付大会的内容，总的来说收货满满，扫盲了很多持续集成，持续交付以及众多分布式相关的技术。\n\n![image](https://images.troyyang.com/2017-11-18-cdconf.png)\n\n\n## 关键点\n### 微服务架构\n微服务毫无疑问是这两年最火的架构模式之一，可惜没有机会实践，但是了解到的是重点在于如何划分服务，更多的可以参考[cnblogs](https://www.cnblogs.com/imyalost/p/6792724.html)上的一篇博文，很全。\n![image](https://images.troyyang.com/2017-11-18-microservices.png)\n\n### 京东架构演变\n听完演讲者的京东架构演变的过程充分验证了金字塔不是一天建成的，互联网产品一直是迭代的，两张京东架构图足以说明他们的技术演变过程：\n\n**架构1.0:**\n![image](https://images.troyyang.com/2017-11-18-jd-v1.png)\n\n**架构3.0:**\n![image](https://images.troyyang.com/2017-11-18-jd-v3.png)\n\n### Serverless\n感觉Serverless 会是另一个未来软件开发的趋势，自己的博客系统里就集成了很多serverless的服务，对于我来说最常见的可能就是类似各种评论系统像DISQUS，多说, （哎，可惜已经关了），存储系统等。当然对企业来说的话，像亚马逊的Lambda这种更能方便客户快速拼接出各种产品，减少开发人员成本。\n\n这个月也参加了亚马逊用户社区活动，里面更是重点提到了Serverless的广泛运用，听完更是为Severless 打call。\n\n## 扫盲篇（未完）：\n\n### elasticsearch\n### jmq\n### binlog\n### 数据库分库分表（取模）\n### jproxy\n### 服务找寻（取模）\n### TRUNKED BASED DEVELOPMENT\n### A/B 测试\n### 蓝绿部署\n### 分布式调用链追踪原理：在相互每个服务请求header中添加trackId\n### 契约测试框架：janus, pact, pacto, spring cloud contract\n### 开发环境区分：dev-qa-sys-perf-uat-prod (我们公司使用的有点不一样localdev-stage-dev-qa-uat-prod)\n\n","tags":["devops"],"categories":["笔记"]},{"title":"Linux下Apache反向代理搭建SSL + Node 服务配置","url":"/2017/11/26/linux_apache_ssl_node/","content":"***\n\n## SSL 配置\n### 证书申请 \nCloudflare生成证书key pair 的pem 格式文件，更名为.crt和.key。文件名和扩展名只是为了提供便利，对功能没有影响；你可以将证书命名为 cert.crt、cert.pem 或 任何其他文件名。\n### 拷贝证书\n使用winSCP 拷贝文件至etc/pki/目录,其中.crt拷贝至etc/pki/tls/certs, .key拷贝至etc/pki/tls/private下。 （由于使用AWS的EC2服务器，拷贝时没有对pki的写权限，所以执行了下面语句将ownship权限赋予ec2-user）\n```\nsudo chown -R -v ec2-user /etc/pki/\n```\n### Linux Apache配置\n安装Apache 模块 mod_ssl 来添加 SSL/TLS 支持\n```\nsudo yum install -y mod24_ssl\n```\n这个时候检查/etc/httpd/conf.d/ssl.conf，你会发现默认的localhost（self-signed）证书已经配置好了。\n这里使用自己的证书，修改Apache配置文件 ssl.conf 中的 配置项\nSSLCertificateFile /etc/pki/certs/test.cer\nSSLCertificateKeyFile /etc/pki/private/test.key\n\n上面的修改是全局的，会对所有站点起作用，如果只布置某个站点，则需要在制定站点的配置里添加下面的配置就好了。找到或创建自己的apache配置文件，可能是/etc/httpd/conf/httpd.conf 或者/etc/httpd/conf.d/ 下默认的xx.conf文件，这里我重新创建一个新的配置以作为我站点的配置文件：\n```\nNameVirtualHost *:443\n<VirtualHost *:443>\nDocumentRoot   /var/www/where\nServerName     where.troyyang.com\nSSLEngine      on\nSSLCertificateFile        /etc/pki/tls/certs/where.troyyang.com.crt\nSSLCertificateKeyFile     /etc/pki/tls/private/where.troyyang.com.key\n</VirtualHost>\n```\n\n### 测试\n\n## 安装[nodejs](https://nodejs.org/en/download/package-manager/)\nOn RHEL, CentOS or Fedora, for Node.js v6 LTS:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -\nsudo yum -y install nodejs\nsudo yum install gcc-c++ make\n```\n\n### Node 测试\n在/var/www/where目录下创建test.js文件\n```\nvar http = require(\"http\");\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(1337);\n```\n\n### Apache 反向代理配置\n```\n<VirtualHost *:443>\n    ServerAdmin admin@site.com\n    ServerName where.troyyang.com\n    SSLEngine      on\n    SSLCertificateFile        /etc/pki/tls/certs/where.troyyang.com.crt\n    SSLCertificateKeyFile     /etc/pki/tls/private/where.troyyang.com.key\n    ProxyRequests off\n    <Proxy *>\n        Order deny,allow\n        Allow from all\n    </Proxy>\n\n    <Location />\n        ProxyPass http://localhost:8080/\n        ProxyPassReverse http://localhost:8080/\n    </Location>\n</VirtualHost>\n```\n重启apache\n```\nsudo httpd -k restart\n```\n启动node\n```\nsudo su root \ncd /var/www/where/\nnode test.js\n```\n浏览器浏览https://where.troyyang.com，输出hello world! 但是一旦退出当前连接session比如putty，则服务停止，所以需要让node服务在后台运行，这里可以使用[forever](https://www.npmjs.com/package/forever)包\n```\nsudo npm install -g forever\ncd /var/www/where/\nforever start test.js\n```\n\n###　部署服务\n- 拷贝源码\n\n```\ncd /var/www/where/\nnpm install\nNODE_ENV=development node app/server.js\n```\n如果用forever\n```\ncd /var/www/where/\nnpm install\nforever stopall\nforever list\nforever start app/server.js NODE_ENV=development\nforever list\n```\n\n>一定要注意Node源码中require的包一定是大小写敏感的，因为Unix系统是文件名大小写敏感，这和Windows系统不一样。就在这里载了个坑，有段代码是require('Joi')，但是找不到joi这个module包，改为require('joi')就对了。\n\n>如果第二次部署时（覆盖原来代码，运行node app/server.js），可能会遇到端口8080使用中，此时可以停用所有node监听端口，再运行\n```\nps aux | grep node\nkillall node\n```\n\n\n\n","tags":["web"],"categories":["笔记"]},{"title":"windows 下搭建https + node.js + nginx","url":"/2017/11/07/windows-ssl-node-nginx/","content":"***\n\n最近做一个微信小程序的时候因为要求所有请求都得是https的连接，服务器端https 倒是搭建好了，可本地测试没法进行啊，于是只能自己在本地搭建个https的服务。\n\n步骤很少，和把大象放进冰箱需要的步骤一样！只需要三步：\n第一步：要使用ssl，肯定需要生成证书，这里我就生成的自签名证书\n第二部：安装nginx和配置ssl\n第三部：用nginx反向代理到node服务端口\n\n\n## 证书生成\n### 安装Openssl\n\n1. 下载地址：http://slproweb.com/products/Win32OpenSSL.html\n（根据系统选择32位或者64位版本下载安装）。\n\n2. 下载完成后，进行安装，默认安装在 C:\\OpenSSL-Win64文件夹中。\n　　\n3. 配置环境变量。在环境变量中添加环境变量Path ：C:\\OpenSSL-Win64\\bin; \n### 自签名证书生成\n```\n> cd c:\\ssl\n// 设置变量\n> set OPENSSL_CONF=C:\\OpenSSL-Win64\\bin\\openssl.cfg\n> echo %OPENSSL_CONF%\n\n//生成server.key\n> >openssl genrsa -out server.key 4096\n\n//生成request文件\n> openssl req -new -key server.key -out server.csr\n\n//获取私钥\n> openssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\n```\n其中，server.crt就是我们的证书，server.key就是私钥。\n\n注意一定要设置变量OPENSSL_CONF不然会有以下错误\n\n```\nc:\\OpenSSL-Win64\\bin>openssl req -new -key server.key -out server.csr\nCan't open C:\\Program Files\\Common Files\\SSL/openssl.cnf for reading, No such file or directory\n6440:error:02001003:system library:fopen:No such process:crypto\\bio\\bss_file.c:74:fopen('C:\\Program Files\\Common Files\\SSL/openssl.cnf','r')\n6440:error:2006D080:BIO routines:BIO_new_file:no such file:crypto\\bio\\bss_file.c:81:\nEnter pass phrase for server.key:\nunable to find 'distinguished_name' in config\nproblems making Certificate Request\n6440:error:0E06D06A:configuration file routines:NCONF_get_string:no conf or environment variable:crypto\\conf\\conf_lib.c:272:\n```\n\n完整过程如下：\n\n\n```\nD:\\ssl>openssl genrsa -out server.key 4096\nGenerating RSA private key, 4096 bit long modulus\n..............................................................................................................................................................................................................++\n.................................................................................................++\ne is 65537 (0x010001)\n\nD:\\ssl>openssl req -new -key server.key -out server.csr\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:CN\nState or Province Name (full name) [Some-State]:SC\nLocality Name (eg, city) []:ChengDu\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (e.g. server FQDN or YOUR name) []:troyyang\nEmail Address []:yangzhoumemail@163.com\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:\nAn optional company name []:\n\nD:\\ssl>x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\n'x509' is not recognized as an internal or external command,\noperable program or batch file.\n\nD:\\ssl>openssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt\nSignature ok\nsubject=C = CN, ST = SC, L = ChengDu, O = Internet Widgits Pty Ltd, CN = troyyang, emailAddress = yangzhoumemail@163.com\nGetting Private key\n\nD:\\ssl>\n```\n\n\n## nginx 搭建\n### 下载安装\n从官网下载nginx 最新稳定版Stable version (非常的小，只有不到2M，我的版本号是1.12.2)  http://nginx.org/en/download.html\n\n然后根据[官方文档](http://nginx.org/en/docs/windows.html)提示解压安装\n```\ncd c:\\\n// unzip nginx-1.12.2.zip (可以手动解压)\ncd nginx-1.12.2\nstart nginx\n```\n\n检测是否启动成功\n```\nC:\\nginx-1.12.2>tasklist /fi \"imagename eq nginx.exe\"\n\nImage Name           PID Session Name     Session#    Mem Usage\n=============== ======== ============== ========== ============\nnginx.exe            652 Console                 0      2 780 K\nnginx.exe           1332 Console                 0      3 112 K\n```\n有两个进程，说明启动成功，一个进程是nginx的主进程，另一个是工作进程。\n\n这里提一点\n> 解压完成后，最好是不要去直接点击nginx.exe文件安装，我就被坑过，解压完成后直接点击，当时什么也没发生，只有窗体闪烁了一下。等到cmd执行start nginx时，怎么都启动不起来。后来执行nginx -s reload后就对了。原因据说是双击运行程序会改变配置文件nginx.conf，所以需要reload。\n\n当nginx启动后，正常情况下，访问localhost应该可以的，会有nginx欢迎页面，如果没有，检查是不是IIS服务器没关，因为IIS会有可能把80端口占用\n\n### 配置SSL\n此时nginx只支持http，所以需要把刚才生成的自签名证书配置到nginx里，找到配置文件\"C:\\nginx-1.12.2\\conf\\nginx.conf\"，然后取消下面注释并配置路径\n```\nserver {\n        listen       443 ssl;\n        server_name  localhost;\n    \n        ssl_certificate      D:\\ssl\\server.crt;\n        ssl_certificate_key  D:\\ssl\\server.key;\n    \n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  5m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n    \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n    }\n```\n访问https://localhost就应该可以看到https安全提醒，选择继续就可以得到如下结果\n![image](https://images.troyyang.com/2017-11-7-nginx-ssl.PNG)\n\n## 反向代理Node 服务\n使用express创建个最简单node服务器，端口为3000\napp.js\n```\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => res.send('Hello World!'))\n\napp.listen(3000, () => console.log('Example app listening on port 3000!'))\n```\n运行服务并确保localhost:3000能访问到。\n```\nnode app.js\n```\n\n### Nginx 反向代理配置\n找到上述Nginx配置文件，将443的server location 改为下面部分：\n```\n    server {\n        listen       443 ssl;\n        server_name  localhost;\n    \n        ssl_certificate      D:\\ssl\\server.crt;\n        ssl_certificate_key  D:\\ssl\\server.key;\n    \n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  5m;\n    \n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n    \n        location / {\n\t\t\tproxy_pass http://localhost:3000;\n\t\t}\n    }\n```\n如果一切OK，访问https://localhost 会得到hello world的输出。至此，一个在windows平台上使用ssl + node + nginx的服务就搭建好了。\n\n参考：\nhttps://stackoverflow.com/questions/7360602/openssl-and-error-in-reading-openssl-conf-file\n\nhttps://blog.didierstevens.com/2015/03/30/howto-make-your-own-cert-with-openssl-on-windows/\n","tags":["node"],"categories":["笔记"]},{"title":"js 笔记之完美继承的演变","url":"/2017/10/21/Javascript_Prototype_Inherience/","content":"首先提个问题，都知道JS中的继承方式演变了很多种，你能完整的写出一种吗？用的最多的又是那种？如果你只能想到SubClass.prototype = new ParentClass()的同学就真该好好面壁了。\n\n前段时间写了一篇[JS继承的简单理解](https://troyyang.com/2017/06/25/Javascript_Prototype_Inherience_Understanding/)，实在是太简单了，主要是为了梳理原型和构造器的关系。最近在对公司新同事的培训中涉及到JS核心部分，所以又仔细去研究了一下，整理出这篇笔记，如有错误，欢迎指出并拍砖。\n\n## 什么是JS 中的继承？\n创建的子类将继承超类的**所有属性和方法**，包括构造函数及方法的实现。记住，所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。\n\n## 完美继承\n以前在开发中，使用继承用得最频繁的继承方式莫过于[MDN](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance)上所推荐的，据说也是最完美的继承，也就是下面这种：\n```\nfunction Person(first, last, age, gender, interests) {\n  this.name = {\n    first,\n    last\n  };\n  this.age = age;\n  this.gender = gender;\n  this.interests = interests;\n};\nPerson.prototype.greeting = function() {\n  alert('Hi! I\\'m ' + this.name.first + '.');\n};\n\nfunction Teacher(first, last, age, gender, interests, subject) {\n  Person.call(this, first, last, age, gender, interests);\n\n  this.subject = subject;\n}\nTeacher.prototype = Object.create(Person.prototype);\nTeacher.prototype.constructor = Teacher;\n```\n\n毫无疑问，这种继承方式是基于原型链的，而并非其他复制方式的继承，而最新ES6 class中的extends也其实就是上面的一种语法糖，所以搞清楚其中的原理至关重要。上面涉及到的东西对于新手而言挺多了，关于this的部分我希望自己再在整理单独一篇文章，而且其实以前使用的时候并没有真正理解所有的地方。以上核心的地方有三个。\n- Person.call \n- Teacher.prototype = Object.create(Person.prototype);\n- Teacher.prototype.constructor = Teacher;\n\n\n## 一步一步往上爬（继承的演变）\n现在忘记上面的最终成品，我们可以一步一步如抽丝剥茧般的达到上述结果。\n\n### 最简单的原型链继承\n```\n function A(a){\n    this.val = a;\n    this.arr = [];\n}\nfunction B(){\n}\nB.prototype = new A();\n\nvar b1 = new B();\nvar b2 = new B();\nb1.val = 1;\nb1.arr.push(1);\nconsole.log(b1.val) // 1\nconsole.log(b1.arr); // 2\nconsole.log(b2.val) // undefined\nconsole.log(b2.arr); // 2\n```\n这可能是很多人的第一个继承版本，可惜因为两个问题根本没法用。\n- 原型对象的引用属性是所有实例共享的 （b1对arr的改变影响到了b2的arr, val则没有影响，因为arr是引用类型）\n- 没法使用父类的构造器参数\n\n### 构造函数继承\n为了解决上述问题，于是改进代码：\n```\n function A(a){\n    this.val = a;\n    this.arr = [];\n    this.func1 = function(){}\n}\nfunction B(param1){\n    A.call(this, param1])\n}\nB.prototype = new A();\n\nvar b1 = new B(1);\nvar b2 = new B(2);\nconsole.log(b1.val) // 1\nconsole.log(b1.arr); // 1\nconsole.log(b2.val) // 2\nconsole.log(b2.arr); // 2\nconsole.log(b1.fun1 === b2.fun1) // false\n```\n好，原型对象属性和构造器参数问题虽然解决了，但是原型的方法并没有实现共享，所以会造成极大的内存浪费，所以也是不可取的。\n\n### 组合继承\n```\nfunction A(a){\n    // 只在此处声明基本属性和引用属性\n    this.val = a;\n    this.arr = [];\n}\n//  在此处声明函数\nA.prototype.func1 = function(){};\n\nfunction B(param1){\n    A.call(this, param1)\n}\nB.prototype = new A();\nvar b1 = new B(1);\nvar b2 = new B(2);\nconsole.log(b1.fun1 === b2.fun1) // true\n```\nA.call(this);继承父类的基本属性和引用属性并保留能传参的优点；通过B.prototype = new A();继承父类函数，实现函数复用。\n\n到了这里，似乎我们找到了最佳继承方式，可惜还是有一个小小的缺点：A构造器会被调用两次, 一次是new A的时候，还有一次是A.apply调用的时候。\n\n### 完美继承\n从组合继承我们可以看出，真正的问题在于new A()。我们在这一步的时候其实仅仅只是想要通用父类prototype中定义的方法（父类的属性我们已经通过apply的那一行调用到了），所以我们只需要改进这一步就好了。\n\n也许你会想，那直接使用A的prototype不就完了\n```\nB.prototype = A.prototype;\n```\n肯定是不行的，因为任何B对原型的修改都讲影响到A的原型，比如我们给B的原型增加一个方法。此外，原型上的构造器也会是同一个B.prototype.constructor === A.prototype.constructor。\n\n怎么办？一个聪明的方式是创建一个空对象然后把空对象的原型指向A的原型，因为这样的空对象是不占用任何内存的。\n```\nvar temp = new Object();\ntemp.__proto__ = A.prototype;\n\nB.prototype = temp;\n```\n\n而其实，上面的代码就是我从[Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)源码中拷贝过来的，所以我们可以改写为：\n```\nB.prototype = Object.create(A.prototype);\n```\n\n综上所述，我们的完美继承应该是这样的：\n```\nfunction A(a){\n    // 只在此处声明基本属性和引用属性\n    this.val = a;\n    this.arr = [];\n}\n//  在此处声明函数\nA.prototype.func1 = function(){};\n\nfunction B(param1){\n    A.call(this, param1)\n}\nB.prototype = Object.create(A.prototype);\n```\n\n然后，还是有个瑕疵（我保证是最后一个）：B.prototype.constructor === Object， 所以，我们这个时候需要重置B的原型构造器指向：\n```\nB.prototype.constructor = B;\n```\n\n好了，完美继承方式就是这样来的，我们在回过头去看看文章开头那段MDN给出的继承方式，是不是所有的都理解了：\n- Person.call \n目的是调用父类构造函数或者仅仅理解为借用构造函数中的代码为自己赋属性值，所以属性都定义在父类构造器中\n- Teacher.prototype = Object.create(Person.prototype);\n目的是父类原型中的函数复用，所以共享方法都定义在父类原型中。\n- Teacher.prototype.constructor = Teacher;\n目的是重置子类原型构造器，具体原因可以参考[why-is-it-necessary-to-set-the-prototype-constructor](https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor)\n\n\n参考：\n\nhttps://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nhttp://www.w3school.com.cn/js/pro_js_inheritance_implementing.asp\nhttp://www.cnblogs.com/ayqy/p/4471638.html\n","tags":["web前端"],"categories":["笔记"]},{"title":"高可靠性MongoDB 安装指南","url":"/2017/09/01/mongo-installation-guide/","content":"\n最近项目中用到了MongoDB，顺便就写了安装说明文档，包括创建高可靠性的副本集replica-set，远程连接，密码登录等配置。\n### 安装 MongoDB\n\n1. 下载 [MongoDB](https://www.mongodb.com/download-center?jmp=nav#community)\n2. 系统环境设置. (Path: C:\\Program Files\\MongoDB\\Server\\3.4\\bin)\n\n### 创建 MongoDB 实例\n\n1. 创建高性能副本集replica-set数据库，打开命令行 (mongod代表着服务器)\n```\n>mkdir d:\\mongodb\\db01\n>mongod --port 27017 --dbpath \"d:\\mongodb\\db01\" --replSet \"rs01dev\"\n```\n运行成功后，副本集db01已经创建成功并处于运行中，此时不关闭命令窗体，保持其运行状态。\n\n2. 初始化 [replica-set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/).\n打开另一个命令窗体，并运行下面命令(mongo代表着客户端)\n```\n>mongo\n>rs.initiate({\n    _id: \"rs01dev\",\n      version: 1,\n      members: [\n         { _id: 0, host : \"127.0.0.1:27017\" }\n      ]\n})\n>rs.config()\n```\n上面的命令将会创建一个主副本集（节点）\n\n3. 创建数据库 'myDB'\n```\n>use myDB\n>db.createUser(\n  {\n    user: \"troyyang\",\n    pwd: \"5469a64fe0a336da365f44f5980f573c\",\n    roles: [\n       { role: \"readWrite\", db: \"myDB\" },\n       { role: \"dbAdmin\", db: \"myDB\" }\n    ]\n  }\n)\n// 上面的命令不会马上创建出数据库，只有插入语句会触发创建数据库\n>db.test.insert({\"name\":\"name1\"})\n```\n\n###  登录验证\n默认情况下，mongo数据库的连接是不需要验证的，这就是为什么上面的那个客户端能直接连接上服务端，所以这样是极其不安全的做法，因此我们这里需要使用登录验证的方式。\n\n关闭上面的客户端命令行，以及服务端。然后打开一个新的命令窗体并执行下面命令开启服务器：\n```\nmongod --auth --port 27017 --dbpath \"d:\\mongodb\\db01\" --replSet \"rs01dev\"\n```\n此时，需要验证的服务器开启完成，非常简单，可以看出，唯一的不同是多了一个 --auth的参数。\n\n###  客户端登录验证测试\n* 命令行客户端测试: 打开一个新的命令行窗体（本机或者外部机器），然后执行:\n```\n>mongo 127.0.0.1:27017 -u \"troyyang\" -p \"5469a64fe0a336da365f44f5980f573c\" --authenticationDatabase \"myDB\"\n```\n\n* Robomongo 测试\n略\n","tags":["No-SQL"],"categories":["数据库"]},{"title":"Hexo-lazyload-image图片懒加载","url":"/2017/08/06/hexo-lazyload-image/","content":"\n### 动机\n最近在看Google Chrome新出的一个API是无意间想到了对图片的懒加载，后来想想自己的网站还不支持呢，索性花了些时间让网站给支持上了，并发现Hexo上还没有一个懒加载的插件，又倒腾着写了个hexo的插件[hexo-lazyload-image](https://www.npmjs.com/package/hexo-lazyload-image)，并发布到NPM上供大家使用，从这几天下载数来看看来大家还是很有这个需求 :)。\n### 图片懒加载\n图片懒加载是提升网站性能和用户体验的一个非常很好方式，并且几乎所有的大型网站都使用到了，比如微博，仅把用户可见的部分显示图片，其余的都暂时不加载，做法就是：让所有图片元素src指向一个小的站位图片比如loading，并新增一个属性(如data-original)存放真实图片地址。每当页面加载（或者滚动条滚动），使用JS脚本将可视区域内的图片src替换回真实地址，并做请求重新加载。 \n### Hexo-lazy-image 实现原理\n因为文章都是使用markdown来编写的，所以不可能要求我们在markdown里将所有图片路径都指向站位图片，并附加另一个属性，所以，这个工作必须留给hexo的generate部分来做。\n\n最终可分为两步： \n1. 在hexo *after_post_render*事件或者*after_render:html*事件里将生产出来的文章html代码中所有img元素都加上 data-original 属性，并把src值付给他， 然后在将src值致为loading图片\n2. 注入simple-lazyload脚本在每个页面最后面，当页面加载过后负责判定当前需要重新加载的图片。\n\n这里重点提提正则表达式，在对第一步替换的时候，只是使用了简单的正则表达式去匹配查找所有的img节点，后来发现不仅如此，正则表达式结合string.replace更是如此强大，直接将我原来30行的代码减为3行，从此热爱上了正则表达式。\n```\nreturn htmlContent.replace(/<img(\\s*?)src=\"(.*?)\"(.*?)>/gi, function (str, p1, p2) {\n        return str.replace(p2, loadingImage + '\" data-original=\"' + p2);\n    });\n```\n\n关于simple-lazyload，这个是懒加载替换脚本的核心，原来使用jquery-lazyload插件，后来觉得没必要，最终还是自己写了个简单版。\n\n\n### Hexo-lazy-image 使用\n安装步骤：\n```\nnpm install hexo-lazyload-image --save\n```\n\n然后修改 _config.yml 文件\n```\nlazyload:\n  enable: true \n  onlypost: false\n  loadingImg: # eg. ./images/loading.png \n```\n\n既然要分享出来，那就得提供更多灵活的API来满足不同的需求，所以又加上了以下功能:\n\n1. 自定义占位图片。（不指定使用默认值）\n2. 只针对文章内容或者全网站图片使用图片懒加载\n\n\n### 关于npm 发布包那点事\n发布NPM包的时候有几个注意事项，这里列一下\n* 每次publish必须在readme中更新版本号(npm patch会自动为你生成最新版本号方便你使用)\n* 要更新npm中的readme页面，需要再次调用npm patch命令，不然尽管你已经更新了readme文件，npm包页面还是保持原来的页面\n* 在packages.json中最好把git地址加上，因为npm会自动解析packages.json文件，会映射到包页面相应的位置\n","tags":["web前端"],"categories":["web前端"]},{"title":"Javascript中原型链继承的简单理解","url":"/2017/06/25/Javascript_Prototype_Inherience_Understanding/","content":"以前对于Javascipt中的继承，大部分只是基于代码层面，理论理解虽然看了很多，总是当时理解了过几天确又忘了怎么的了。这两天又看了一遍《Javascrip面向对象编程指南》，其中在说到原型链的时候有一段话解释了很多以前自己容易混淆的地方：\n> 首先我们知道每个对象都会有一个构造器，而原型本身也是一个对象，这意味着它必然也有一个构造器，而这个构造器又会有自己的原型，于是这种结构就会持续下去，形成一个原型链。\n\n## 实践出真知\n理解这段话并不难，可如果没有在实践中去理解，就会像以前一样，老是记不住。\n### 实例对象的各种属性\n先看看最简单的内置对象string类型的各种构造函数（构造器）和原型，a一定是实例化的对象，而不是构造函数(构造函数一般是大写)。\n\n![image](https://images.troyyang.com/2017-6-25-js-inherence.png)\n\n从上面我们可以很直观的看到很多东西：\n- a是由String构造函数(constructor)创建的。\n- a的构造器函数(constructor)是有原型(prototype)的。\n- a是没有原型属性(prototype)的。\n- 神秘的__proto__直接是对a构造器的原型的引用。\n\n所以如果a里有我们继承的原型属性值rating，我们平时就可以这样使用:\n```\na.constructor === String\na.constructor.prototype.rating === a.rating\n```\n\n### 构造函数的原型\n\n在JS中实现继承的方式有很多，而我最喜欢这种[Mozilla](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)推荐的:\n```\nfunction User(auth) {\n    BaseManager.call(this, auth);\n}\nUser.prototype = Object.create(BaseManager.prototype); // IE8 不支持Object.create\nUser.prototype.constructor = User;\n```\n代码其实不难，也容易理解，首先是构造函数内调用基类，然后是原型覆盖，最后是构造函数重新赋值。其中最最最应该理解的是User是个构造函数而不是实例化的对象，只有构造函数是有prototype属性的，这和上面的实例化对象a是不一样的。\n","tags":["web前端"],"categories":["笔记"]},{"title":"Travis-ci自动编译部署github上的项目","url":"/2017/06/24/Travis_Auto_Build_Deploy_Github_Projects/","content":"在使用Hexo写完一篇博客后，都需要手动在本地编译，并生成静态文件，最后在上传至github服务器上才能发布，繁琐步骤姑且不说，万一哪天换了台电脑，没有Hexo环境的时候如何写博客呢又或者修改博客Bug？要是直接在github源码里写好文章后能自动编译发布就好了，好在github的好基友travis可以轻松帮我们同时实现这种持续集成, 持续部署。\n## 前因\n我的博客是基于[Hexo](https://hexo.io/)写的，最终发布地址是托管到Troy-Yang/troy-yang.github.io下的，为了方便，我把源码放在他的一个source分支下，以前要写一篇博客的做法是：\n1. 获取Source分支，使用markdown写好文章放在指定目录\n2. 安装搭建hexo环境\n3. 使用Node编译这个hexo项目\n4. 使用Node发布编译后的结果到github上\n\n缺点显而易见，我必须要搭建hexo的环境，并且还需要获取到source源码，而我只是想写一个markdown啊或者修改博客里某个css文件的bug，所以最理想的做法就是能自动检测到我的源码改动并自动编译部署，就和我们平时项目开发时的CI、CD一样。\n\n## [Travis](https://travis-ci.org/)\n不想介绍太多它，只想提一点的是它只针对开源项目免费，并且和github上的项目集成，所以所有github上的项目都可以使用它做CI、CD。\n> 这也就是为什么我们看到很多github上的项目都有.travis.yml文件\n和任何CI服务器一样，它的作用就在于可以捕捉任何代码提交并自动化的编译部署项目。\n\n## 第一步，github上添加access token\n登录github，进入到setting => develop setting => personal access tokens\n\n在description里输入任意token 名字，比如Travis-CI，并勾选上下面所有复选框。这个时候会生成token，请务必记住，因为他只会出现一次，否则需要重新生成(这个就是)。\n\n![image](https://images.troyyang.com/2017-6-24-github-create-token.png)\n\n\n## 第二步，添加github上的项目至travis上\n使用github账号登录[https://travis-ci.org/](https://travis-ci.org/)，这个时候你会看到自己所有github上的项目，选择需要做自动集成的项目troy-yang.github.io\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-create.png)\n\n## 第三步, 添加access token到travis上\n第一步和第三步的目的是保护你的access token除了travis和你自己以外别人都看不到，你肯定不希望把access token放在.travis.yml文件里让大家都看到吧。\n\n在travis上进入troy-yang.github.io 后，在右上角more options里找到setting，打开后，勾选 [Build only if .travis.yml is present] 并且 在Environment Variables中添加github上的access token。\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-setting.png)\n\n## 第四步,　添加编写.travis.yml\n在项目源码根目录(我的是troy-yang.github.io source分支), 添加.travis.yml文件，内容如下:\n```\nlanguage: node_js\nnode_js: stable\n\n# S: Build Lifecycle\ninstall:\n  - npm install\n\nbefore_install:\n  - git submodule update --init --remote --recursive\n  \n#before_script:\n # - npm install -g gulp\n\nscript:\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"troyyang\"\n  - git config user.email \"yangzhouemail@163.com\"\n  - git add .\n  - git commit -m \"Update docs\"\n  - git push --force --quiet \"https://${GitHub_TOKEN}@${GH_REF}\" master:master\n# E: Build LifeCycle\n\nbranches:\n  only:\n    - Source\nenv:\n global:\n   - GH_REF: github.com/Troy-Yang/troy-yang.github.io.git\n```\n\n里面最重要的可能就是执行脚本和变量，脚本。 其中hexo g是编译hexo 项目命令，after_script是编译命令完成后将结果推送至github项目下。${GitHub_TOKEN} 和 ${GH_REF}是两个占位符，第一个就是我们在Travis项目下添加的Token，会在travis执行的时候自动替换，第二个就是下面env的一个变量，这里我们也可以不要这个变量直接放地址也可以。还有一点的是branch指定，我们这里只需要Source 分支。\n\n根据不同项目，travis.yml文件内容各有不同, Travis上的一个官方demo文件[.travis.yml]( https://github.com/travis-ci/cat-party/blob/master/.travis.yml)\n\n## 第五步，测试\n让我们试试直接浏览器登录github，然后在troy-yang.github.io.git下的source分支下提交任何文件修改。在登录Travis，此时你可以看到一旦提交，Travis这边马上开始执行流程，看起来非常赏心悦目。\n\n![image](https://images.troyyang.com/2017-6-24-travis-ci-build.png)\n\n从此发布文件，修改博客bug是如此容易！博客如此，其他开源项目同样如此。\n","tags":["hexo"],"categories":["笔记"]},{"title":"踩过的坑--CORS跨域请求中预检(preflight)","url":"/2017/06/06/Express_Cors_Preflight_Request/","content":"***\n### 开头\n这两天在使用NodeJS Express搭建REST服务器时遇到一个很典型的AJAX跨域包含自定义请求头问题（用于身份验证），在花了大半天时间排查问题后发现自己对CORS真正的理解还很不够，尤其是pre-flight。\n\n### 需求描述\n服务端使用NodeJS Express搭建包含JWT身份验证的REST Full API， 客户端在获取到JWT信息之后的每次API请求头中都附带上JWT信息，完成身份验证后才能执行API操作，否则返回401错误。\n\n#### 代码\n\n服务器端(CORS核心部分):\n\n```\n------ App -----\n...\n// Enable CORS from client-side\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, OPTIONS\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials\");\n  res.header(\"Access-Control-Allow-Credentials\", \"true\");\n  next();\n});\n\n//parse application/json and look for raw text                                        \napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.text());\napp.use(bodyParser.json({ type: 'application/json' }));\n\n// Routes configuration\napiRoutes(app);\n\napp.listen(port);\n\n------- User -----\n//==========================\n// User Routes\n//==========================\napiRoutes.use('/user', passport.authenticate('jwt', {session: false }), userRoutes);\nuserRoutes.get('/', user.getUsers);\nuserRoutes.get('/:id', user.getUser);\nuserRoutes.post('/', user.postUser);\nuserRoutes.put('/:id', user.updateUser);\nuserRoutes.delete('/:id', user.deleteUser);\n```\n\n上面的代码看起来还是那么多清晰，在PostMan 测试中附带jwt也是没有任何的问题，成功返回。\n![image](https://images.troyyang.com/2017-06-05-CORS-Postman.PNG)\n\n接下来是客户端(jquery ajax):\n\n```\n------- Core --------\nfunction BaseManager(auth) {\n    this.baseApiUrl = 'http://localhost:8080/api/';\n    this.auth = auth;\n}\nBaseManager.prototype.get = function (url, successCallback, errorCallback) {\n    this.ajax(url, {}, 'get', successCallback, errorCallback);\n}\nBaseManager.prototype.ajax = function (url, data, type, successCallback, errorCallback) {\n    let that = this;\n    $.ajax({\n        url: url,\n        method: type,\n        data: data,\n        beforeSend: function (req) {\n            req.setRequestHeader('Authorization', that.auth.authorizationToken);\n        }\n    })\n        .done(successCallback)\n        .fail(errorCallback);\n}\n----------- User -------\nUser.prototype.getUserById = function (id, successCallback, errorCallback) {\n    let url = this.baseApiUrl + '/user/' + id;\n    this.get(url, successCallback, errorCallback);\n}\n```\n\n### 永远的401\n然后， 问题出现了，尽管参数是如何的对，Chrome console下总是返回让人咬牙切齿的大红色401，甚至断点都没有进入到passport的Jwt middleware下。\n![image](https://images.troyyang.com/2017-06-05-401-error.PNG)\n\n无数次的尝试，先是怀疑客户端ajax调用没对，甚至搬用最原生的ajax方法， 也怀疑过是服务端Jwt passport没写对，最后比较http请求头的时候发现了一些问题。\n\n使用Post man在node服务器端得到的request是这样的：\n\n![image](https://images.troyyang.com/2017-06-05-request-header-postman.PNG)\n\n通过浏览器ajax请求是这样的：\n![image](https://images.troyyang.com/2017-06-05-request-header-browser.PNG)\n\n有人给我把请求头信息更改了！Authorization不见了，甚至连req.method都变成了OPTIONS，而不是GET。\n\n### 罪魁祸首---预检(Pre-flight)\n百思不得其解，Google相关关键词后，pre-flight浮出水面，到了这步，突然想起阮一峰的《[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)》，当时只是略读，大概了解CORS中有两种请求：简单请求和非简单请求。于是又翻出来看了下，此时的情况正是属于非简单请求，会发送两次的请求，第一次就是preflight，用于请求验证, 第二次才是用户真正需要发送的请求。\n\n对于Pre-flight权威的解读： [mozilla.org](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests )\n\n回到代码中，不巧，每次服务端捕捉到的就是这个preflight请求，然后做next，其中就包括Jwt 中间件，而因为请求头中没有Authorization这个header，Jwt就返回了401，而这个过程是在passport的JWT中自动检测的，自己写的JWT验证部分甚至都没有执行到！\n\n### 解决办法\n看了[express cors](https://github.com/expressjs/cors/blob/master/lib/index.js)源码后，其实把请求类型OPTIONS做个简单的过滤就好啦！！！\n\n```\n// Enable CORS from client-side\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, OPTIONS\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials\");\n  res.header(\"Access-Control-Allow-Credentials\", \"true\");\n  if (req.method == \"OPTIONS\") {\n    res.send(200);\n  }\n  else {\n    next();\n  }\n});\n```\n\n### 结语\n又想了一下为什么之前的项目一直没有这个问题，其实是因为很多框架以及帮我们实现好了，比如说.NET中的WebAPI, 在做验证的时候我们都不用去考虑需要捕捉pre-flight请求，而在express中，甚至如果我当初直接使用三方库[express cors](https://github.com/expressjs/cors/blob/master/lib/index.js) 也可以避免，但是幸运的是，因为这种偶然，我们更有机会看得更清楚这些请求的后面到底是什么。\n\n看似简单的问题，却包括了很多需要自己去了解的东西，尤其是http各种请求头的含义，比如Content-type, Accept, 以及对应ajax应该传递的参数，最后，当然还有 Pre-flight!\n","tags":["jwt"],"categories":["笔记"]},{"title":"给Github自定义域名加上HTTPS","url":"/2017/05/21/Add_Free_Certification_In_Blog_Step_By_Step/","content":"***\n \n### 写在开头\n随着Https越来越成为一种趋势，最近也给自己家博客弄上了高大上的https，主要是结合使用的cloudflare和七牛云（图床）使用，关键是免费！所以想把这个过程记录下来，万一有人用得到呢。(还想抽空写写对Https的原理的理解，主要目的还是总结前段时间自己对Https的学习。)\n\n### Https时代\n>According to Mozilla since January 2017 more than half of the Web traffic is encrypted. [wiki pedia](https://en.wikipedia.org/wiki/HTTPS) \n\n维基百科告诉我们，自从2017年1月，超过一半的网络请求是通过加密过后的。百度也告诉站长们：\n> 为了给用户提供一个安全可靠的网络环境，继启用https加密之后，百度搜索再次重磅推出：全面支持https页面直接收录；另外从相关性的角度，百度搜索引擎认为权值相同的站点，采用https协议的页面更加安全，排名上会优先对待。[百度站长](http://zhanzhang.baidu.com/wiki/392)\n\nGoogle 今年更厉害，从1月份开始，所有没有用Https的网站会在Chrome浏览器地址栏前面加上不安全的图标：\n>Beginning in January 2017 (Chrome 56), we’ll mark HTTP pages that collect passwords or credit cards as non-secure, as part of a long-term plan to mark all HTTP sites as non-secure. [Google](https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html)\n\n百度2015年实现全站HTTPS，并且Google和百度都收录Https的网站并且提高其搜索排名，国外大型互联网网站基本都使用https，所以，有人说2017年是一个Https年。那既然如此，高大上的Https我们普通老百姓玩得起吗？要知道，一般的Https证书动辄也是几千块一年！\n\n### 天上掉下个证书\n没错，Cloudflare免费提供给证书，尽管你没有自己的服务器。Cloudflare是一个相当厉害的DNS服务商和CDN提供商，提供各种安全防范解决方案，全世界各地都有他的节点，对于国内，百度选择和他一起合作就是个很好的栗子，所以不用担心国内解析速度。所以我准备把主站的证书使用Cloudflare提供的。\n\n再一个就是七牛云，作为博客，不可能把文章图片全都放github上，所以最好还是要有自己的图床，但是好多图片床都是不支持https的，好在七牛可以免费申请证书。所以这是第二个证书。\n\n### 准备\n因为自己的博客站点暂时是托管到github上的，不是自己的服务器，所以并不能使用[Let's encrypt](https://letsencrypt.org/)在服务器端生成免费的证书，但好在一切都有cloudflare!\n\n- ~~有一个自己的域名~~（废话）\n- 自己的Github博客地址 (一般都是https://[username].github.io)\n- 注册Cloudflare\n- 注册七牛云 （如果有自己的图片床，并支持https, 可省去）\n\nCloudflare，主要用于域名解析，这是成功的关键！只有在他那里域名解析，他才能为我们提供多种证书服务。\n\n### 开始第一步: Github 自定义域名\n我们知道Github可以托管开源和私自项目(私有收费)，同样，功能强大的Github也可以提供静态页面站点，默认站点是 **https://[username].github.io** ，对应的站点代码是在reponsitory名为[username].github.io 下，如果没有，请创建自己的默认repository，可参考官方[说明](https://pages.github.com/)\n\n![image](https://images.troyyang.com/2017-5-21-https-github-home.png)\n创建成功后，我们就成功的创建了自己的个人站点: https://troyyang.github.io 显然这还不是我们的最终目的。\n\n接下来，打开这个repository, 定位到repo setting，绑定自己的域名，绑定完成后，我们可以看到repo代码下新加了一个CNAME的文件，换句话说，其实我们也可以直接在repo中直接添加这个文件即可，而不需要在setting中去手动设置，这个在我们静态站点发布的时候非常有用，因为每次发布后提交都会删除原有的文件，所以我们就可以在生成的文件中默认加上这个文件。\n\n![image](https://images.troyyang.com/2017-5-21-https-github-home-customdomain.png)\n\nCNAME\n```\ntroyyang.com\n```\n\n### 第二步：使用Cloudflare解析域名\n#### 修改默认DNS服务器\n在使用Cloudflare之前，我使用的是万网（现在是阿里云）的默认DNS服务器，也就是\n```\ndns9.hichina.com\ndns10.hichina.com\n```\n现在修改为Cloudflare\n```\napollo.ns.cloudflare.com\nmary.ns.cloudflare.com\n```\n个人觉得cloudflare作为DNS服务器特别快，修改了任何A记录或者其他记录会马上生效，不用再等待几个小时。\n#### 域名解析\n登录cloudflare, 将域名A记录指向Github服务器地址(同时也可指定CNAME记录去加上www)，绑定完成几分钟后访问troyyang.com或者www.troyyang.com 就可以访问到我们Github上那个默认的repo静态站点。这个时候可以尝试去访问https://troyyang.com 理论上是不会成功的，哈哈。\n![image](https://images.troyyang.com/2017-5-21-dns-cloudflare.png)\n\n### 第三步：使用Cloudflare的 Universal SSL 证书\n在Cloudflare管理页面，导航到Crypto，我们会看到SSL在Cloudflare上使用证书有三种方式: Flexible、Full、Full Strict，\n- Flexible SSL: 在访客与Cloudflare之间是加密的，从Cloudflare到自己服务器是不加密的，所以\n1. 你不需要在站点服务器上安装任何证书。\n2. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自Cloudflare）\n- Full SSL: 从访客到Cloudflare, 从Cloudflare到站点服务器都是加密的。Full 和 Full (Strict)不同之处在于Full Strict会去验证你服务器上的证书是否合法，而Full不会验证，所以你可以在你服务器上安装任何证书，包括自签名证书也是可以的。当然\n1. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自Cloudflare）\n- Full SSL (strict): 从访客到Cloudflare, 从Cloudflare到站点服务器都是加密的。你必须在你的服务器上安装有可信赖的CA证书，这个证书必须是未过期，包含有域名等信息的。同样\n1. 访客可以在浏览器地址栏上看到加密的图标。（证书签名来自自己申请的CA）\n\n三种模式如图\n![image](https://images.troyyang.com/2017-5-21-cloudflare-ssl.png)\n\n当然，我们选择Flexible，选择后我们还需要在下面的Edge Certificates栏目中新增Universal SSL 证书（当初以为选择Flexible后就等待24小时激活就完了，可几天过去了状态一直处于initilizing certification, 问了客服后，客服帮我加上这个Universal SSL证书就好了，给他们客服赞一个）\n\n在Edge Certificates中，点击Order SSL Certificate按钮，弹出几种证书，我们当然选择免费的那个, 然后填写证书服务的域名troyyang.com和*.troyyang.com.\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-universal-ssl.png)\n\n一步一步完成后就等待了，一般情况不会超过24小时就会生效，激活后就如下图（我个人选的是Full），然后就可以尽情的访问 https://troyyang.com\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-universal-ssl-success.png)\n\n如何你查看域名证书，细心的你除了看到Cloudflare签发的证书外，还有证书有效期只有半年，这个不用担心过期，客服小哥回复说他们会在快过期时自动延期的。\n\n![image](https://images.troyyang.com/2017-5-21-cloudflare-ssl-troyyang.png)\n\n### 七牛图床Https支持\nCloudflare客服小哥在帮我加好Universal SSL证书后，回复我说你网站还包括非https的内容也就导致所谓的mixed-content 问题，也就导致我当时在地址栏还看不到那个https图标，这个是我能想到的，因为我知道我的图片还都不是https，因为图片存放在七牛云上的，赶紧回去看看七牛是怎么支持https，于是在踩了无数坑过后终于让图片支持上了。\n\n#### 第一步： 在七牛上使用自定义域名 (images.troyyang.com)\n要使用https图床，必须得使用自定义域名（我使用的是images.troyyang.com），这个比较简单，可以参考[页面](https://developer.qiniu.com/fusion/manual/1367/custom-domain-name-binding-process)，我们可以先不选择https模式，让正常http先工作。主要工作就是在Cloudflare上新增一个CNAME记录指向七牛为自己域名生成的域名地址就好了。一切正常后，我们应该可以访问任意图片比如http://images.troyyang.com/2017-05-01-hexo-2015-wordpress.jpg\n\n要使用自定义域名，在七牛上，你必须等往账号里充至少10元，让自己成为标准用户，\n\n#### 第二步： 给自定义域名加上https支持\n现在要给自己的自定义图片域名加上https支持，在七牛上有两种方式，一种是上传自己已有的证书，第二种是申请免费证书或者购买证书。对于第一种，除了上传自己的证书公钥以外，还需要私钥也一同上传，所以我还是选择的第二种，反正也只是一个二级域名的证书，也并不存在任何私密性的东西。\n\n在七牛管理页面，在证书页面选择购买证书，然后选择TrustAsia的DV限免性，最关键的就是DNS的TXT验证了（[验证指南](https://developer.qiniu.com/fusion/manual/1703/qiniu-free-certificate)），我也是在使用了三次申请后才弄明白申请失败原因: Github上默认会解析出两个IP地址\n\n![image](https://images.troyyang.com/2017-5-21-qiniu-dig.png)\n\n解决方案就是，在Cloudflare上先删除所有A记录，CNAME记录，先添加上用作域名验证的Txt记录，等证书申请成功后（大约十几分钟），在恢复A记录，CNAME记录。这个是我Cloudflare上的相关解析最终样子\n![image](https://images.troyyang.com/2017-5-21-cloudflare-dns-all.png)\n\n有一点需要说明的是在七牛上如果只使用http的话，只要一个月不超过20G流量，是不会收费的，但是https是不在免费额度里面的。 \n\n\n\n","tags":["https"],"categories":["security"]},{"title":"《CSS设计指南》笔记","url":"/2017/04/20/Learn_Stylin_With_Css/","content":"## 选择器\n- 子元素 > :  用于选择所有给定子元素，如 .food>li\n- 后代元素： 用于选择所有子代和后代元素，如 .food li\n- 子-星 > *：用于选择所有直接子元素，而不包括后代元素. 注意：在为子元素设定垂直外边距时，只能使用 margin-top 和 margin-bottom，不能使用简写的 margin，否则会抵消用“子-星选择符”应用给这些元素 的水平外边距，如果你想进一步缩进某个子元素的内容，就应该给该子元素应用内边距如让子元素与栏边界保持一定距离\n```\narticle > * {margin:0 20px;}\n```\n- 非首位子元素 + : 这个选择符会选择除第一个之外的所有指定元 素，如\n```\n.list1 li + li {border-top:1px solid #f00;} \n```\n\n## 盒子模型\n- box-sizing:border-box 可用于避免改变内边距（边框）时导致整个盒子尺寸变化(width此时只是代表内容的宽度)，\n- .Inner 另一种解决盒子尺寸变化的方式就是在其内部再包一层盒子\n\n## 布局\n- 使用table-cell 布局(css3)\n```\nnav {display:table-cell; width:150px; padding:10px;      background:#dcd9c0;} \narticle {display:table-cell; padding:10px 20px;      background:#ffed53;} \naside {display:table-cell; width:210px; padding:10px;      background:#3f7ccf;} \n```\n\n## Display\n- 将行内元素改为块级元素实现文本选择范围扩大\n如，导航栏中文本\n```\n.list1 a {display:block; padding:3px 10px; textdecoration:           none; font:20px Exo, helvetica, arial, sansserif; \n```\n\n## font\n- 常用颜色\n![image](https://images.troyyang.com/2017-6-1-regular-colors.PNG)\n\n## background-clip\n借助[background-clip](https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip/)可以实现类似外边距分割效果，如\n```\n.multi-drop-menu ul {\n    float: left;\n}\n\n.multi-drop-menu li {\n    float: left;\n    list-style-type: none;\n}\n.multi-drop-menu a {\n    display: block;\n    color: #555;\n    background-color: #eee;\n    padding: .2em 1em;\n    border-width: 3px;\n    border-color: transparent;\n}\n.multi-drop-menu li a {\n    display: block;\n    border-right-style: solid;\n    background-clip: padding-box;\n    text-decoration: none;\n}\n\n<nav class=\"multi-drop-menu vertical\">\n\t<ul>\n        <li><a href=\"#\">Shirts</a></li>\n        <li><a href=\"#\">Pants</a></li>\n        <li><a href=\"#\">Dresses</a></li>\n        <li><a href=\"#\">Shoes</a></li>\n    </ul>\n</nav>\n```\n类似的用途如facebook的弹出框\n\n![image](https://www.w3cplus.com/sites/default/files/facebook-effects.jpg)\n> 使用background-clip把元素背景控制在padding或content区域内，这样一来，只需一个非常div，我们在这个div上加上透明边框，并配合background-clip把背景超过padding或content的边缘外的背景色直接裁剪掉著作权归作者所有。\n商业转载请联系作者获得授权,非商业转载请注明出处。\n原文: http://www.w3cplus.com/content/css3-background-clip © w3cplus.com\n","tags":["css"],"categories":["笔记"]},{"title":"小米路由器 安装 Shadowsocks 客户端","url":"/2017/04/16/XiaoMi_Router_Install_Shadowsocks/","content":"\n### 前因\n当然是为了省去多个终端连接的烦恼，而我的直接原因确是为了Google神器Chromecast能正常使用（就单单是电视投射功能就足以让我心动）。大半年前在美国买了一个Chromecast，在美国的时候工作的好好的，回国后确怎么也投射不了，总是找不到设备，大概猜到是因为被墙的原因，可惜电脑挂起了VPN还是不行，后来才知道是电视也需要连接Google 服务！坑爹啊！然后就一直静静的放着放着直到这次买了个服务器(也是为了科学上网)后，想试试让路由器直接连Shadowsocks。\n### 准备\n- 一台运行着Shadowsocks，并且能访问外网的服务器\n- 一台小米MINI路由器（其他的也行）\n- 一台装载了linux远程连接客户端的电脑(XShell或者Putty)\n\n### 第一步：开启路由器SSH\n我的是小米MINI路由器，因为默认是稳定版而不是开发版，所以第一步就是升级（也可能是降级）到开发版去开启SSH，具体步骤在[这里](http://jingyan.baidu.com/article/624e7459ae65e834e8ba5afd.html)或者 [这里](http://bbs.xiaomi.cn/t-10044297)\n> 升级前可以先备份路由信息\n\n### 第二步：连接到路由器\n升级完成后，使用在小米官网给出当前小米账号的root账号密码便可以登录路由器系统XIAO QIANG, 实质也是linux系统的一个distribution，查询后得知事实上生活中很多小的硬件设备都是搭载的linux系统，因为其开销实在太小啦\n![image]https://images.troyyang.com/2017-04-15-LoginXiaoMiRouter.PNG)\n\n查询当前路由器系统信息\n\n```\nuname -a\n/// Linux XiaoQiang 2.6.36 #1 MiWiFi-R1CM-2.15.75 Thu Apr 13 17:10:07 CST 2017 mips GNU/Li\n```\n\n### 第三部：安装Shadowsocks\n原本以为这个shadowsocks客户端其实就是github上的那个Linux Shadowsocks, 然后似乎并不是，只能猜测针对当前路由器又做过一次包装, 然后就发现了这么一个宝藏一键安装脚本：[http://d.ukoi.net/Miwifi/](http://d.ukoi.net/Miwifi/) \n\n也不知道作者是谁，只能猜测是对小米路由器系统很了解的人，所以根据这些安装脚本，我们就可以一步一步走向世界！之前试过很多小米论坛上的脚本，可惜基本都是不能下载的，所以很感激这位作者。\n\n运行下面的脚本:\n> 可以根据不同的小米路由器版本选择不同的脚本，更改相应的部分\n\n```\n// userdisk目录下的文件不会被系统reset\ncd /userdisk\n// 下载\nwget http://d.ukoi.net/Miwifi/MINI/mini_install.sh\n// 对文件赋权限\nchmod +x mini_install.sh\n// 安装\nsh mini_install.sh\n```\n\n之后就是按照输入要求输入客户端连接的一些参数，完成后不出意外基本没问题啦，家里面所有wifi覆盖的地方都能愉快的科学上网，当然最重要的就是我的电视也能投射啦。。。。\n\n还有一点就是这个脚本使用的是IP分流的，也就是说只有在GFW列表里的网站才会使用VPS，所以可以放心使用。\n\n参考\n\nhttp://www.miui.com/forum.php?mod=viewthread&tid=4133822&extra=\n\n\n\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"Ubuntu 安装 Shadowsocks 实现科学上网","url":"/2017/03/26/Ubuntu_Install_ShadowSocks/","content":"\n***\n\n### 开头\n看了shadowsocks的各种安装部署教程，因为对于linux不熟，所以遇到很多坑，自己留个笔记在这里\n### 更新\n使用Ubuntu 14.04 版本已经不是必须的，当时主要是因为在最新版本Ubuntu内核没在锐速支持列表中，现在发现一种新的拥塞加速算法BBR（Google开发的），而且默认在最新的Ubuntu内核4.11已经集成进去，所以只需要开启即可，再也不用考虑已经不提供官方服务的锐速。完成安装ShadowSocks 后，参见秋水逸冰的《[一键安装最新内核并开启 BBR 脚本](https://teddysun.com/489.html)》。\n### 环境准备\nOS: \n- Ubuntu 14.04 X64 LTS\n- Kernel Linux 3.13.0-112-generic\n\n> 似乎 从16.04 开始以上已经全面使用[systemd](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)来启动管理守护进程，而不是像传统在init.d来启动。\n\n\nVPS 平台: Vultr\n远程控制客户端: XShell 或者 Putty\n\n### 远程连接 ubuntu\n略\n### Shadowsocks 安装\n\n安装pytyon 的pip管理程序，因为shadowsocks是由python写的\n```\n$ apt-get install python-pip\n```\n\n安装shadowsocks程序 (方式一)\n\n```\n$ sudo pip install shadowsocks\n```\n安装shadowsocks程序 (方式二), pip 上的不是最新版本)\n\n```\n# 安装yum\n# 安装Python setuptools\n$ sudo apt-get install python-setuptools\n# 从github上安装shadowsocks\n$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master\n```\n\n\n查看是否安装成功\n\n```\n$ ssserver\n$ whereis ssserver\n```\n\n创建服务器配置文件(多端口)\n\n```\n$ vi  /etc/shadowsocks.json\n```\n\n\nvim 的命令: 按 \"i\" 进入编辑模式，编辑后按 \"esc\" 退出编辑模式， 输入 \":wq\" 保存退出vi\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\": {\n         \"443\": \"password1\",\n         \"8888\": \"password2\"\n     },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n启动服务，后台运行\n\n```\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n此时可配置好客户端shadowsocks检测是否可以访问\n\n### 设置开机启动(针对16.10以下版本)\n\n```\n$ vim /etc/rc.local\n```\n在exit 0以前插入开机执行命令\n\n```\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n### ShadowSocks 操作命令\n查看日志\n\n```\n$ sudo less /var/log/shadowsocks.log\n```\n\n### 防火墙端口开放\n```\nsudo iptables -I INPUT -p tcp --dport 8888 -j ACCEPT\n```\n为防止reboot后iptable重置，需要下面命令\n```\nsudo apt-get install iptables-persistent\n\nsudo /etc/init.d/iptables-persistent save \nsudo /etc/init.d/iptables-persistent reload\n##或者\nsudo netfilter-persistent save\nsudo netfilter-persistent reload\n```\n\n### BBR 加速\n一定要使用加速，使用和不使用的差别是：没使用时查看youtube 720P 看不了，速度只有区区6、70KB的速度，使用后瞬间7、800甚至1m，发挥出了带宽的最大威力！\nhttps://www.linuxbabe.com/ubuntu/enable-google-tcp-bbr-ubuntu\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"从wordpress主题中看CSS设计","url":"/2017/03/11/Learn_CSS_from_wordpress_theme/","content":"\n***\n\n### 写在开头\n最近想做个个人博客，看上了wordpress的[twentyfifteen](https://wordpress.org/themes/twentyfifteen/)模板页(2015默认模板)，看上了就想拥有，而拥有是需要付出代价的，于是就掉入了源码坑里，爬了一周才算勉强爬出来，回过头来觉得这个坑里还是有很多有营养的东西，毕竟是大公司，所有标准都是最新的，所以想总结下学到的东西，方便以后使用(持续更新中)\n\n***\n##  Responsive page (干货都写在最前面)\n在移动互联网时代，responsive的页面是必须的，我们知道css3里的media 可以帮我们实现不同设备尺寸的不同显示方式，所以设备尺寸的一个界定值就是我们的一个首要考虑问题，其他不多说，看看人家是如何定义的：\n\n```\n/**\n * 16.1 Mobile Large 620px\n */\n @media screen and (min-width: 38.75rem) {\n}\n/**\n * 16.2 Tablet Small 740px\n */\n\n@media screen and (min-width: 46.25rem){\n}\n\n/**\n * 16.3 Tablet Large 880px\n */\n @media screen and (min-width: 55rem){}\n\n/**\n * 16.4 Desktop Small 955px\n */\n \n@media screen and (min-width: 59.6875rem){\n}\n/**\n * 16.5 Desktop Medium 1100px\n */\n \n@media screen and (min-width: 68.75rem){\n}\n/**\n * 16.6 Desktop Large 1240px\n */\n@media screen and (min-width: 77.5rem){\n}\n```\n其中在mock的过程中发现几个tips\n* 上面只有min-width，没有设置max-width，这是一个灵活的设计，没有max-width就说明他可以从最小满足条件的media开始，只要满足条件，都会被执行到，而我们需要做的就是把共有的部分写在最小尺寸里，或者放最外面，然后在需要更改的部分属性在在需要的尺寸中更改。简单举个栗子：\n有个导航栏，需要在移动设备的时候隐藏，在桌面浏览器中显示所有，那我们可以这样:\n![](https://images.troyyang.com/2017-03-03-css-media-query.jpg)\n\n***\n\n##  如何在css文件中使用fontawesome图标字体库\n我们知道的是要在页面中使用fontawesome的图标很简单，只需要在html代码中加入如下代码\n```\n<i class=\"fa fa-address-book-o\" aria-hidden=\"true\"></i><a href=\"#\">列表</a>\n```\n其中fa代表的是默认图标大小，如果想改变图标的大小，可以使用集成的fa-lg(放大33%),fa-2x, fa-3x, fa-4x, fa-5x。所以用起来很爽是吧。\n\n从wordpress中(其实他没有用fontawesome图标库，而是他们自己的genericons库)，我看到了他是在css中定义这些图标的，试想一下，如果每次使用图标都需要新添加一个元素是不是很累赘，而且重复呢，这不符合程序设计的可复用原则啊！所以很自然的就想到使用class,这样就可以很轻松的在一些元素之前借助于伪类:before加上content神器自动加入，而我需要做的仅仅是在a标签加上一个class名称。\n\n其中很重要的一步是引入这个新font-family FontAwesome。\n实现如下：\n\n```\n[class*=\"font-asesome-icon\"]:before {\n  font-family: FontAwesome;\n  font-weight: normal;\n  font-style: normal;\n  display: inline-block;\n}\n\n.secondary-toggle:before {\n    color: #333;\n\tfont-size: 2rem;\n    content: \"\\f0c9\";\n    line-height: 40px;\n    width: 40px;\n}\n\n<a class=\"font-asesome-icon secondary-toggle\" href=\"#\">列表</a>\n```\n其中content代表的是该图标的Unicode, 每个fontawesome图标库里都能查到其对应的unicode。\n上面的是问题一，还有个问题是，我如何改变图标的大小呢？哈哈，我们回想一下这是什么库？对，字体库，所以，既然是字体，改变大小不就是font-size！我们上面是font-size:2rem，也就等于2*16px（rem是什么鬼一会再说），其实仔细查看fontawesome[官网](http://fontawesome.io/examples/)，然后任选一个图标，点击view css，我们会看到他的实现源码如下:\n\n```\n.@{fa-css-prefix}-lg {\n  font-size: (4em / 3);\n  line-height: (3em / 4);\n  vertical-align: -15%;\n}\n.@{fa-css-prefix}-2x { font-size: 2em; }\n.@{fa-css-prefix}-3x { font-size: 3em; }\n.@{fa-css-prefix}-4x { font-size: 4em; }\n.@{fa-css-prefix}-5x { font-size: 5em; }\n```\n\n## px, em, rem\n\n### 基本概念\n**px (pixel，像素)**：是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果px要换算成物理长度，需要指定精度DPI(Dots Per Inch，每英寸像素数)，在扫描打印时一般都有DPI可选。Windows系统默认是96dpi，Apple系统默认是72dpi\n\n**em** (相对长度单位，相对于当前对象内文本的字体尺寸)：是一个相对长度单位，最初是指字母M的宽度，故名em。现指的是字符宽度的倍数，用法类似百分比，如：0.8em, 1.2em,2em等。通常1em=16px\n\n**rem**（root em，根em）(相对长度单位，相对于根节点```html```的字体尺寸)\n\n\n在wordpress博客中看到使用了```rem```，之前只知道```em```，查看了[相关资料](https://webdesign.tutsplus.com/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984)后，学习到了:\n\n- rem 和 em 都是根据你设计的fontsize值最终被浏览器解释成pixel的\n- em 的值是根据当前他坐在的元素fontsize决定的\n- rem的值是由html根节点的fontsize决定的\n- em的值会被父元素的fontsize继承在计算(除非使用pixel显示的设置了当前元素的固定fontsize大小)\n- rem的值会被在浏览器设置中设置的fontsize大小影响(除非在html根节点下使用了pixel去固定fontsize大小)\n- 有时为了换算方便，经常为body设置fontsize 为65%\n\n### 如何选择 \n- 使用rem: 在文本大小值的设置上使用\n- 使用rem或者px: 在media queies中使用\n- 在和文本布局相关中，可使用em，比如某些文本的padding, margin 布局。防止因文本大小变化导致布局变得混乱\n- 在多列布局中，不要使用em或者rem来作为宽度，而使用 ```%```代替\n\n","tags":["css"],"categories":["web前端"]}]